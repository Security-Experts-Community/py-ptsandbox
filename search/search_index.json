{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"Async API connector for PT Sandbox instances"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Fully typed</li> <li>Completely asynchronous</li> <li>Just a modern python</li> </ul>"},{"location":"#installation","title":"Installation","text":"PyPiuvnix <pre><code>pip install ptsandbox\n</code></pre> <pre><code>uv add ptsandbox\n</code></pre> <pre><code>TBA\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Getting a list of all installed images using the API:</p> <pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main() -&gt; None:\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n    print(await sandbox.api.get_images())\n\nasyncio.run(main())\n</code></pre> <p>Getting system settings using the UI API:</p> <pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n        ui=SandboxKey.UI(\n            login=\"login\",\n            password=\"password\",\n        ),\n    )\n\n    sandbox = Sandbox(key)\n    # You must log in before using the UI API\n    await sandbox.ui.authorize()\n\n    print(await sandbox.ui.get_system_settings())\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/proxy/","title":"Proxy","text":"<p>In some environments, it is not possible to access the internet directly, you can use the proxy for this:</p> Code example<pre><code>from ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    sandbox = Sandbox(\n        key=SandboxKey(...),\n        proxy=\"socks5://10.10.10.30\"\n    )\n</code></pre> <p>The library uses aiohttp-socks, so you can view the supported proxy types in it.</p>"},{"location":"usage/public-api/download-files/","title":"Download files","text":"<p>You can download files from the sandbox using a <code>sha256</code> hash.</p> Code example<pre><code>from ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    sandbox = Sandbox(key=SandboxKey(...))\n\n    data = await sandbox.get_file(\"...\")\n    with open(\"./file\", \"wb\") as fd:\n        fd.write(data)\n</code></pre> <p>Streaming is also supported if you don't need to download the entire file into memory:</p> Code example<pre><code>import aiofiles\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    sandbox = Sandbox(key=SandboxKey(...))\n\n    async with aiofiles.open(\"./file\", \"wb\") as fd:\n        async for chunk in sandbox.get_file_stream(\"...\"):\n            await fd.write(chunk)\n</code></pre> Download all files from a task <pre><code>import asyncio\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Coroutine\nfrom uuid import UUID\n\nimport aiofiles\n\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import ArtifactType\n\nsemaphore = asyncio.Semaphore(12)\n\n\nasync def save_file(sandbox: Sandbox, file: Path, hash: str) -&gt; None:\n    file.parent.mkdir(parents=True, exist_ok=True)\n\n    async with semaphore:\n        async with aiofiles.open(f\"{file}.{hash}\", \"wb\") as fd:\n            async for chunk in sandbox.get_file_stream(hash):\n                await fd.write(chunk)\n\n    print(f\"saved {file}\")\n\n\nasync def main(task_id: UUID) -&gt; None:\n    sandbox = Sandbox(\n        key=SandboxKey(\n            name=\"test-key-1\",\n            key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n            host=\"10.10.10.10\",\n        ),\n    )\n\n    result = await sandbox.get_report(task_id)\n    if (report := result.get_long_report()) is None:\n        print(\"Can't get full report\")\n        return\n\n    tasks: list[Coroutine[Any, Any, None]] = []\n    for artifact in report.artifacts:\n        if not (sandbox_result := artifact.find_sandbox_result()):\n            continue\n\n        if not sandbox_result.details:\n            continue\n\n        if not sandbox_result.details.sandbox:\n            continue\n\n        if not sandbox_result.details.sandbox.artifacts:\n            continue\n\n        for file in sandbox_result.details.sandbox.artifacts:\n            if not file.file_info:\n                continue\n\n            if file.type != ArtifactType.FILE:\n                continue\n\n            tasks.append(\n                save_file(\n                    sandbox,\n                    Path(\"artifacts\") / Path(file.file_info.file_path.removeprefix(\"/\")),\n                    file.file_info.sha256,\n                )\n            )\n\n    await asyncio.gather(*tasks)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(UUID(sys.argv[1])))\n</code></pre> <p>Restrictions</p> <p>The sandbox currently has a restriction that doesn't allow you to view the task report if it was created with another token, so you can download only your own files.</p>"},{"location":"usage/public-api/email/","title":"Extract email headers","text":"<p>Upload an email and get its headers.</p> Code example<pre><code>import aiofiles\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    sandbox = Sandbox(key=SandboxKey(...))\n\n    async with aiofiles.open(\"./email-headers\", \"wb\") as fd:\n        async for chunk in sandbox.get_email_headers(Path(\"./email.bin\")):\n            fd.write(chunk)\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def get_email_headers(self, file: str | Path | bytes | BinaryIO) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Upload an email to receive headers\n\n    Args:\n        file: path to .eml file or just binary data\n\n    Returns:\n        The header file\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    match file:\n        case str() | Path():\n            with open(file, \"rb\") as fd:\n                data = BytesIO(fd.read())\n            iterator = self.api.get_email_headers(data)\n        case bytes():\n            iterator = self.api.get_email_headers(BytesIO(file))\n        case BytesIO():\n            iterator = self.api.get_email_headers(file)\n        case _:\n            raise SandboxException(f\"Unsupported type: {type(file)}\")\n\n    async for chunk in iterator:\n        yield chunk\n</code></pre>"},{"location":"usage/public-api/image-info/","title":"Get available images","text":"<p>Getting a list of installed images in the sandbox:</p> Code example<pre><code>from ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    key = SandboxKey(...)\n    sandbox = Sandbox(key)\n\n    images = await sandbox.get_images()\n    print(images)\n</code></pre> <p>Example output</p> <pre><code>[\n    SandboxImageInfo(image_id='ubuntu-jammy-x64', ...),\n    SandboxImageInfo(image_id='win10-1803-x64', ...),\n    ...\n]\n</code></pre> Response model in <code>ptsandbox/models/core/common.py</code> <pre><code>class SandboxImageInfo(BaseModel):\n    \"\"\"\n    Information about the VM image\n    \"\"\"\n\n    class OS(BaseModel):\n        \"\"\"\n        Information about the operating system of the virtual machine\n        \"\"\"\n\n        name: str\n        \"\"\"\n        Name of the operating system\n        \"\"\"\n\n        version: str\n        \"\"\"\n        Operating system version\n        \"\"\"\n\n        architecture: str\n        \"\"\"\n        Processor architecture supported by the operating system\n        \"\"\"\n\n        service_pack: str | None = Field(\n            default=None,\n            validation_alias=AliasChoices(\"service_pack\", \"servicePack\"),\n        )\n        \"\"\"\n        The name of the operating system update package\n        \"\"\"\n\n        locale: str\n        \"\"\"\n        Operating system locale\n        \"\"\"\n\n    image_id: str = Field(validation_alias=AliasChoices(\"image_id\", \"name\", \"id\"))\n    \"\"\"\n    ID of the VM image\n\n    The new UI began to return the name of the image. However, in the form of a name.\n    \"\"\"\n\n    type: SandboxImageType | None = None\n    \"\"\"\n    The type of image.\n    \"\"\"\n\n    version: str\n    \"\"\"\n    Version of the VM image\n    \"\"\"\n\n    os: OS | None = None\n    \"\"\"\n    Information about the operating system of the virtual machine image\n    \"\"\"\n</code></pre>"},{"location":"usage/public-api/system/","title":"System info","text":""},{"location":"usage/public-api/system/#check-api-status","title":"Check API Status","text":"Code example<pre><code>from ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    key = SandboxKey(...)\n    sandbox = Sandbox(key)\n\n    status = await sandbox.check_health()\n    print(status)\n</code></pre> Response model in <code>ptsandbox/models/api/maintenance.py</code> <pre><code>class CheckHealthResponse(BaseResponse):\n    \"\"\"\n    Healthcheck results\n    \"\"\"\n\n    class Data(BaseModel):\n        status: str\n        \"\"\"\n        Health status\n        \"\"\"\n\n    data: Data\n</code></pre>"},{"location":"usage/public-api/system/#get-product-version","title":"Get product version","text":"Code example<pre><code>from ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    key = SandboxKey(...)\n    sandbox = Sandbox(key)\n\n    version = await sandbox.get_version()\n    print(version)\n</code></pre> Response model in <code>ptsandbox/models/api/maintenance.py</code> <pre><code>class GetVersionResponse(BaseResponse):\n    \"\"\"\n    Get information about product\n    \"\"\"\n\n    class Data(BaseModel):\n        version: str\n        \"\"\"\n        Product version, for example '5.11.0.12345'\n        \"\"\"\n\n        edition: str\n        \"\"\"\n        Filled in for test builds or certification builds.\n        \"\"\"\n\n    data: Data\n</code></pre>"},{"location":"usage/public-api/tasks/","title":"Tasks","text":""},{"location":"usage/public-api/tasks/#get-available-tasks","title":"Get available tasks","text":"<p>Warning</p> <p>So far, this method may not be available on all instances of the sandbox. It will appear in future releases.</p> <p>This method is needed to get a list of tasks without using the UI API.</p> Example of getting the last 20 scans (default value)<pre><code>from ptsandbox import Sandbox, SandboxKey\n\nasync def example() -&gt; None:\n    key = SandboxKey(...)\n    sandbox = Sandbox(key)\n\n    result = await sandbox.get_tasks()\n    for task in result.tasks:\n        print(task.id, task.name)\n</code></pre>"},{"location":"usage/public-api/scanning/debug-options/","title":"Debug Options","text":"<p>Warning</p> <p>Full support for debugging options is not guaranteed.</p> <p>They can constantly change both on the library side and on the product side.</p> <p>Don't use them in production code.</p> <p>When creating any scan task, you can specify <code>DebugOptions</code>, which allow you to additionally configure the sample launch parameters.</p> Source code in <code>ptsandbox/models/api/analysis.py</code> <pre><code>class DebugOptions(TypedDict):\n    \"\"\"\n    Description of all available debugging options for very detailed scan configuration\n    \"\"\"\n\n    keep_sandbox: NotRequired[bool]\n    \"\"\"\n    Don't destroy the sandbox after scanning\n    \"\"\"\n\n    skip_work: NotRequired[bool]\n    \"\"\"\n    Perform a scan, skipping the data collection stage for analysis\n    \"\"\"\n\n    extract_crashdumps: NotRequired[bool]\n    \"\"\"\n    Extract crashdumps from the sandbox\n    \"\"\"\n\n    save_debug_files: NotRequired[bool]\n    \"\"\"\n    Save files necessary for debugging (error logs, tcpdump logs, etc)\n    \"\"\"\n\n    rules_url: NotRequired[str]\n    \"\"\"\n    Use the specified normalization and correlation rules\n    The rules are specified as a link to the archive containing the compiled rules\n    \"\"\"\n\n    sleep_work: NotRequired[bool]\n    \"\"\"\n    Perform a scan, replacing the data collection stage for analysis with an equivalent waiting time\n    \"\"\"\n\n    disable_syscall_hooks: NotRequired[bool]\n    \"\"\"\n    Disable syscall hooks functionality\n\n    Read more about these hooks in documentation\n    \"\"\"\n\n    disable_dll_hooks: NotRequired[bool]\n    \"\"\"\n    Disable dll hooks functionality\n\n    Read more about these hooks in documentation\n    \"\"\"\n\n    custom_syscall_hooks: NotRequired[str]\n    \"\"\"\n    Use the specified list of system calls to intercept\n\n    The list is transmitted as an http link to a file with the names of system calls\n\n    Read more about this file in documentation\n    \"\"\"\n\n    custom_dll_hooks: NotRequired[str]\n    \"\"\"\n    Use the specified list of system calls to intercept\n\n    The list is transmitted as an http link to a file with the names of dll hooks for apimon plugin\n\n    Read more about this file in documentation\n    \"\"\"\n\n    disable_retries: NotRequired[bool]\n    \"\"\"\n    Disable task re-execution in case of a scan error\n    \"\"\"\n\n    enable_sanitizers: NotRequired[bool]\n    \"\"\"\n    Enable the debugging mechanisms of the sanitizers group\n    \"\"\"\n\n    allowed_outbound_connections: NotRequired[list[str]]\n    \"\"\"\n    Whitelist of IP addresses to which connections from a VM are allowed (backconnect)\n    \"\"\"\n\n    payload_completion_event: NotRequired[str]\n    \"\"\"\n    A regular expression for the raw DRAKVUF event, signaling the end of the useful work of the sample.\n\n    If this option is specified, sandbox-worker will calculate and log the PAYLOAD_SCAN_TIME metric.\n    \"\"\"\n\n    disable_procdump_on_finish: NotRequired[bool]\n    \"\"\"\n    Disable the functionality of removing the memory dump from the sample at the end of the observation\n    \"\"\"\n\n    skip_update_time: NotRequired[bool]\n    \"\"\"\n    Do not synchronize the time in the VM with the host\n    \"\"\"\n\n    disable_manual_scan_events: NotRequired[bool]\n    \"\"\"\n    Do not send lifecycle notifications for manual behavioral analysis (console is ready, console is closed, etc.)\n    \"\"\"\n\n    bootkitmon_boot_timeout: NotRequired[int]\n    \"\"\"\n    The maximum waiting time for VM loading in seconds (90 seconds by default)\n    \"\"\"\n\n    custom_procdump_exclude: NotRequired[str]\n    \"\"\"\n    A file with a list of processes for which memory dumps should not be removed.\n\n    Each line in the file is a regular expression of the path to the process file on disk.\n\n    Read more about this file in documentation\n    \"\"\"\n\n    custom_fileextractor_exclude: NotRequired[str]\n    \"\"\"\n    A file with a list of files that should not be extracted\n\n    Each line in the file is a regular expression of the path to the file on disk.\n\n    Read more about this file in documentation\n    \"\"\"\n\n    validate_plugins: NotRequired[bool]\n    \"\"\"\n    Check plugins for at least one event during the entire behavioral analysis\n    \"\"\"\n\n    extra_vm_init_url: NotRequired[str]\n    \"\"\"\n    Run this script in the VM immediately before launching the behavioral analysis.\n\n    It is useful, for example, to check the network during analysis.\n    \"\"\"\n</code></pre>"},{"location":"usage/public-api/scanning/debug-options/#custom_syscall_hooks","title":"custom_syscall_hooks","text":"<p>Allows you to set your own list of system calls to intercept.</p> <p>Be careful, hooking a frequently used syscall can significantly slow down the analysis.</p> LinuxWindows <pre><code>cachestat\nchdir\nfstat\nopen\nread\nwrite\n</code></pre> <pre><code>NtQueryKey\nNtQueryLicenseValue\nNtQueryObject\nNtQueryValueKey\nNtRaiseException\nNtReadFile\nNtSetValueKey\nNtShutdownSystem\nNtSuspendThread\n</code></pre> <p>The full list of system calls:</p> <ul> <li>Linux - syscalls.mebeim.net</li> <li>Windows - j00ru.vexillium.org</li> </ul> <p>Usecase</p> <p>It is necessary to check some unique sample, and the sandbox doesn't track the function of interest.</p>"},{"location":"usage/public-api/scanning/debug-options/#custom_dll_hooks","title":"custom_dll_hooks","text":"<p>It's not a well-documented thing, so use it carefully.</p> <p>format:</p> <pre><code>&lt;FunctionName&gt;,log,&lt;PARAM1&gt;:&lt;TYPE1&gt;,&lt;PARAM2&gt;:&lt;TYPE2&gt;\n</code></pre> Windows <pre><code>AbortSystemShutdownA,log,lpMachineName:lpstr\nAbortSystemShutdownW,log,lpMachineName:lpwstr\nInitiateShutdownA,log,lpMachineName:lpstr,lpMessage:lpstr,dwGracePeriod:dword,dwShutdownFlags:shutdown_flags,dwReason:shutdown_reason\nwaveInOpen,log,phwi:lpvoid,uDeviceID:int,pwfx:lpvoid,dwCallback:lpvoid,dwInstance:lpvoid,fdwOpen:dword\n</code></pre> <p>Usecase</p> <p>It is necessary to check some unique sample, and the sandbox doesn't track the function of interest.</p>"},{"location":"usage/public-api/scanning/debug-options/#custom_procdump_exclude","title":"custom_procdump_exclude","text":"<p>Allows you to use regular expressions to specify a list of processes that will be ignored during a memory dump.</p> <p>To check that a regular expression is exactly right, use regex101.com and Golang flavor.</p> LinuxWindows <pre><code>^kworker\\/\\d:\\d$\n^\\/usr\\/bin\\/.*$\n</code></pre> <pre><code>^\\\\device\\\\harddiskvolume\\d+\\\\windows\\\\system32\\\\csrss\\.exe$\n</code></pre> <p>Usecase</p> <p>It allows you to significantly speed up the analysis if you need to ignore any flooding processes.</p>"},{"location":"usage/public-api/scanning/debug-options/#custom_fileextractor_exclude","title":"custom_fileextractor_exclude","text":"<p>Allows you to use regular expressions to specify a list of files that will be ignored during extraction.</p> LinuxWindows <pre><code>^\\/etc\\/(nsswitch|host|resolv)\\.conf$\n^\\/lib32\\/ld-.*\\.so$\n</code></pre> <pre><code>^.*\\\\users\\\\.*\\\\appdata\\\\local\\\\google\\\\chrome\\\\user data\\\\default\\\\favicons-journal$\n^.*\\\\windows\\\\prefetch\\\\.*$\n</code></pre> <p>Usecase</p> <p>It allows you to significantly speed up the analysis if you need to ignore any flooding files.</p>"},{"location":"usage/public-api/scanning/rescan/","title":"Rescan","text":"<p>In the sandbox, it is possible to re-scan the collected logs without using the sample used (retro tasks). In the interface, they are indicated as the results of the analysis.</p> <p>The following files are required for rescan:</p> <ul> <li><code>drakvuf-trace.log.zst</code> - events collected from the analysis system;</li> <li><code>tcpdump.pcap</code> - information about network interaction;</li> </ul> Code example<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    task = await sandbox.create_rescan(\n        trace=Path(\"./drakvuf-trace.log.zst\"),\n        network=Path(\"./tcpdump.pcap\"),\n    )\n\n    result = await sandbox.wait_for_report(task)\n    if (report := result.get_long_report()) is not None:\n        print(report.artifacts)\n\n\nasyncio.run(main())\n</code></pre> <p>Getting a report without additional waiting</p> <p>If you need to send and receive the scan result immediately, you can set the <code>async_result=False</code> parameter and the sandbox will immediately send the finished result.</p> <pre><code>task = await sandbox.create_rescan(\n    trace=Path(\"./drakvuf-trace.log.zst\"),\n    network=Path(\"./tcpdump.pcap\"),\n    async_result=False\n)\nprint(task.get_long_report())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def create_rescan(\n    self,\n    trace: str | Path | bytes | BytesIO,\n    network: str | Path | bytes | BytesIO,\n    /,\n    *,\n    rules: str | Path | bytes | BytesIO | None = None,\n    priority: int = 3,\n    short_result: bool = False,\n    async_result: bool = True,\n    read_timeout: int = 300,\n    options: SandboxBaseScanTaskRequest.Options = SandboxBaseScanTaskRequest.Options(),\n) -&gt; SandboxBaseTaskResponse:\n    \"\"\"\n    Run a retro scan to check for detects without running a behavioral analysis.\n\n    It is useful if there is a trace from a malware that can't connect to C2C.\n\n    Or is it necessary to check the new correlation rules on the same trace.\n\n    Args:\n        trace: path to drakvuf-trace.log.zst or just bytes\n        network: path to tcpdump.pcap or just bytes\n        rules: if you have compiled the rules, then you can rescan with them, rather than using the sandbox embedded inside\n        priority: the priority of the task, between 1 and 4. The higher it is, the faster it will get to work\n        short_result:\n            Return only the overall result of the check.\n\n            The parameter value is ignored (true is used) if the value of the `async_result` parameter is also `true`.\n        async_result:\n            Return only the scan_id.\n\n            Enabling this option may be usefull to send async requests for file checking.\n\n            You can receive full report in a separate request.\n        read_timeout: response waiting time in seconds\n        options: additional sandbox options\n\n    Returns:\n        The response from the sandbox is either with partial information (when using async_result), or with full information.\n\n    Raises:\n        SandboxUploadException: if an error occurred when uploading files to the server\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    try:\n        async with asyncio.TaskGroup() as tg:\n            task_dummy = tg.create_task(self.api.upload_file(file=config.FAKE_PDF))\n            task_trace = tg.create_task(self.api.upload_file(file=trace))\n            task_network = tg.create_task(self.api.upload_file(file=network))\n\n            if rules is not None:\n                task_rules = tg.create_task(self.api.upload_file(file=rules))\n            else:\n                task_rules = None\n    except* aiohttp.client_exceptions.ClientResponseError as e:\n        raise SandboxUploadException(\"Can't upload files to server\") from e\n\n    uploaded_dummy = task_dummy.result()\n    uploaded_trace = task_trace.result()\n    uploaded_network = task_network.result()\n\n    if task_rules is not None:\n        uploaded_rules = task_rules.result()\n        options.sandbox.debug_options[\"rules_url\"] = uploaded_rules.data.file_uri\n\n    scan = SandboxRescanTaskRequest(\n        file_uri=uploaded_dummy.data.file_uri,\n        file_name=config.FAKE_NAME,\n        raw_events_uri=uploaded_trace.data.file_uri,\n        raw_network_uri=uploaded_network.data.file_uri,\n        short_result=short_result,\n        async_result=async_result,\n        priority=priority,\n        options=options,\n    )\n\n    return await self.api.create_rescan(scan, read_timeout)\n</code></pre>"},{"location":"usage/public-api/scanning/scan/","title":"Scan","text":""},{"location":"usage/public-api/scanning/scan/#default-scan","title":"Default scan","text":"<p>Regular scanning allows you to send files to the sandbox without super fine-tuning the settings.</p> Code example<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import SandboxBaseScanTaskRequest, SandboxOptions\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    task = await sandbox.create_scan(\n        Path(\"./example.py\"),\n        options=SandboxBaseScanTaskRequest.Options(\n            sandbox=SandboxOptions(\n                image_id=\"ubuntu-jammy-x64\",\n                analysis_duration=30,\n            )\n        ),\n    )\n\n    result = await sandbox.wait_for_report(task)\n    if (report := result.get_long_report()) is not None:\n        print(report.result.verdict)\n\n\nasyncio.run(main())\n</code></pre> <p>Usecase</p> <p>This is useful when you just need to send a file for analysis with a minimum number of options.</p> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def create_scan(\n    self,\n    file: str | Path | bytes | BinaryIO,\n    /,\n    *,\n    file_name: str | None = None,\n    rules: str | Path | bytes | BytesIO | None = None,\n    priority: int = 3,\n    short_result: bool = False,\n    async_result: bool = True,\n    read_timeout: int = 300,\n    upload_timeout: float = 300,\n    options: SandboxBaseScanTaskRequest.Options = SandboxBaseScanTaskRequest.Options(),\n) -&gt; SandboxBaseTaskResponse:\n    \"\"\"\n    Send the specified file to the sandbox for analysis\n\n    Args:\n        file: the file to be sent for analysis\n        file_name:\n            The name of the file to be checked, which will be displayed in the sandbox web interface.\n\n            If possible, the name of the uploaded file will be taken as the default value.\n\n            If not specified, the hash value of the file is calculated using the SHA\u2014256 algorithm.\n        rules: if you have compiled the rules, then you can scan with them, rather than using the sandbox embedded inside\n        priority: the priority of the task, between 1 and 4. The higher it is, the faster it will get to work\n        short_result:\n            Return only the overall result of the check.\n\n            The parameter value is ignored (true is used) if the value of the `async_result` parameter is also `true`.\n        async_result:\n            Return only the scan_id.\n\n            Enabling this option may be usefull to send async requests for file checking.\n\n            You can receive full report in a separate request.\n        read_timeout: response waiting time in seconds\n        upload_timeout: if a large enough file is being uploaded, increase timeout (in seconds).\n        options: additional sandbox options\n\n    Returns:\n        The response from the sandbox is either with partial information (when using async_result), or with full information.\n\n    Raises:\n        SandboxUploadException: if an error occurred when uploading files to the server\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    upload_name: str | None = file_name\n    if not upload_name:\n        match file:\n            case str() | PathLike():\n                upload_name = str(file)\n            case _:\n                upload_name = None\n\n    try:\n        async with asyncio.TaskGroup() as tg:\n            task_file = tg.create_task(self.api.upload_file(file=file, upload_timeout=upload_timeout))\n            if rules is not None:\n                task_rules = tg.create_task(self.api.upload_file(file=rules, upload_timeout=upload_timeout))\n            else:\n                task_rules = None\n    except* aiohttp.client_exceptions.ClientResponseError as e:\n        raise SandboxUploadException(\"Can't upload files to server\") from e\n\n    uploaded_file = task_file.result()\n\n    if task_rules is not None:\n        uploaded_rules = task_rules.result()\n        options.sandbox.debug_options[\"rules_url\"] = uploaded_rules.data.file_uri\n\n    scan = SandboxScanTaskRequest(\n        file_uri=uploaded_file.data.file_uri,\n        file_name=upload_name,\n        short_result=short_result,\n        async_result=async_result,\n        priority=priority,\n        options=options,\n    )\n\n    return await self.api.create_scan(scan, read_timeout)\n</code></pre>"},{"location":"usage/public-api/scanning/scan/#options","title":"Options","text":"<p>A set of options that additionally allow you to configure the analysis parameters</p> <p>In them, you can set the scan image, your command to run, etc.</p> <p>You can read more details in the model code.</p> Source code in <code>ptsandbox/models/api/analysis.py</code> <pre><code>class SandboxOptions(BaseRequest):\n    \"\"\"\n    Parameters of behavioral analysis.\n\n    In the absence, the source parameters are used for analysis, which are set in the system by default.\n    \"\"\"\n\n    class FilterProperties(BaseModel):\n        \"\"\"\n        Filtering a group of files by properties to send to the sandbox for analysis\n        \"\"\"\n\n        pdf: list[FileInfoProperties] = []\n\n        office: list[FileInfoProperties] = []\n\n    enabled: bool = True\n    \"\"\"\n    Perform a behavioral analysis\n    \"\"\"\n\n    image_id: str = \"win7-sp1-x64\"\n    \"\"\"\n    ID of the VM image.\n\n    You can view it in the sandbox interface.\n    \"\"\"\n\n    custom_command: str | None = None\n    \"\"\"\n    The command to run the file.\n\n    The `{file}` marker in the string is replaced with the path to the file.\n\n    For example: `rundll32.exe {file},#1`\n    \"\"\"\n\n    procdump_new_processes_on_finish: bool = False\n    \"\"\"\n    Take dumps for all spawned and non-dead processes\n    \"\"\"\n\n    analysis_duration: int = Field(default=120, ge=10)\n    \"\"\"\n    The duration of analysis the file in seconds. minimum: 10\n    \"\"\"\n\n    bootkitmon: bool = False\n    \"\"\"\n    Perform bootkitmon analysis\n    \"\"\"\n\n    analysis_duration_bootkitmon: int = Field(default=60, ge=10)\n    \"\"\"\n    The duration of analysis at the bootkitmon stage in seconds. minimum: 10\n    \"\"\"\n\n    save_video: bool = True\n    \"\"\"\n    Save video capture of the screen\n    \"\"\"\n\n    mitm_enabled: bool = True\n    \"\"\"\n    Enable certificates injection with PT Sandbox certificates when decrypting and analyzing secure traffic\n    \"\"\"\n\n    file_types: list[str] | None = None\n    \"\"\"\n    A list of the final file types or groups of files that will be sent for behavioral analysis\n\n    For example:\n    [\"adobe-acrobat/\", \"databases/\", \"executable-files/\", \"presentations/\", \"spreadsheets/\", \"word-processor/\"]\n    \"\"\"\n\n    filter_by_properties: FilterProperties | None = None\n    \"\"\"\n    Filtering a group of files by properties to send to the sandbox for analysis\n    \"\"\"\n\n    debug_options: DebugOptions = {\"save_debug_files\": False}\n    \"\"\"\n    Fine-tuning\n    \"\"\"\n</code></pre>"},{"location":"usage/public-api/scanning/scan/#url","title":"URL","text":"<p>In addition to checking files, it is possible to check URLs.</p> <p>It is mainly used to download a file from a link and send it to the sandbox for further analysis.</p> Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import SandboxOptions, SandboxScanURLTaskRequest\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    task = await sandbox.create_url_scan(\n        \"http://malware.com/malicious-file\",\n        options=SandboxScanURLTaskRequest.Options(\n            sandbox=SandboxOptions(\n                image_id=\"ubuntu-jammy-x64\",\n                analysis_duration=30,\n            )\n        ),\n    )\n\n    result = await sandbox.wait_for_report(task)\n    if (report := result.get_long_report()) is not None:\n        print(report.result.verdict)\n\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def create_url_scan(\n    self,\n    url: str,\n    /,\n    *,\n    rules: str | Path | bytes | BytesIO | None = None,\n    priority: int = 3,\n    short_result: bool = False,\n    async_result: bool = True,\n    read_timeout: int = 300,\n    options: SandboxBaseScanTaskRequest.Options = SandboxBaseScanTaskRequest.Options(),\n) -&gt; SandboxBaseTaskResponse:\n    \"\"\"\n    Send the url to the sandbox\n\n    Args:\n        url: the url to be sent for analysis\n        rules: if you have compiled the rules, then you can scan with them, rather than using the sandbox embedded inside\n        priority: the priority of the task, between 1 and 4. The higher it is, the faster it will get to work\n        short_result:\n            Return only the overall result of the check.\n\n            The parameter value is ignored (true is used) if the value of the `async_result` parameter is also `true`.\n        async_result:\n            Return only the scan_id.\n\n            Enabling this option may be usefull to send async requests for file checking.\n\n            You can receive full report in a separate request.\n        read_timeout: response waiting time in seconds\n        options: additional sandbox options\n\n    Returns:\n        The response from the sandbox is either with partial information (when using async_result), or with full information.\n\n    Raises:\n        SandboxUploadException: if an error occurred when uploading files to the server\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    if rules is not None:\n        try:\n            uploaded_rules = await self.api.upload_file(file=rules)\n        except aiohttp.client_exceptions.ClientResponseError as e:\n            raise SandboxUploadException(\"Can't upload rules to server\") from e\n\n        options.sandbox.debug_options[\"rules_url\"] = uploaded_rules.data.file_uri\n\n    scan = SandboxScanURLTaskRequest(\n        url=url,\n        file_name=None,  # will be excluded\n        short_result=short_result,\n        async_result=async_result,\n        priority=priority,\n        options=options,\n    )\n\n    return await self.api.creat_url_scan(scan, read_timeout)\n</code></pre>"},{"location":"usage/public-api/scanning/scan/#advanced-scan","title":"Advanced scan","text":"<p>For example, we need to fine-tune the sample launch parameters, put additional files in the sandbox, etc.</p> <p>This can be done with advanced scanning options.</p> Code example<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import SandboxOptionsAdvanced\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    task = await sandbox.create_advanced_scan(\n        Path(\"./example.elf\"),\n        extra_files=[Path(\"./file.txt\"), Path(\"./file.sh\")], # (1)!\n        sandbox=SandboxOptionsAdvanced( # (2)!\n            image_id=\"ubuntu-jammy-x64\",\n            analysis_duration=30,\n            disable_clicker=True,\n        ),\n    )\n\n    result = await sandbox.wait_for_report(task)\n    if (report := result.get_long_report()) is not None:\n        print(report.result.verdict)\n\n\nasyncio.run(main())\n</code></pre> <ol> <li>The library does not check the existence of files</li> <li>We specify <code>SandboxOptionsAdvanced</code> instead of <code>SandboxOptions</code></li> </ol> <p>Tip - enable manual analysis</p> <pre><code>task = await sandbox.create_advanced_scan(\n    Path(\"./example.exe\"),\n    sandbox=SandboxOptionsAdvanced(\n        image_id=\"win11-23H2-x64\",\n        analysis_duration=600,\n        disable_clicker=True,\n        vnc_mode=VNCMode.FULL,\n    )\n)\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def create_advanced_scan(\n    self,\n    file: str | Path | bytes | BinaryIO,\n    /,\n    *,\n    file_name: str | None = None,\n    rules: str | Path | bytes | BytesIO | None = None,\n    extra_files: list[Path] | None = None,\n    short_result: bool = False,\n    async_result: bool = True,\n    read_timeout: int = 300,\n    upload_timeout: float = 300,\n    priority: int = 3,\n    sandbox: SandboxOptionsAdvanced = SandboxOptionsAdvanced(),\n) -&gt; SandboxBaseTaskResponse:\n    \"\"\"\n    Send the specified file to the sandbox for analysis using advanced API\n\n    :warning: It may not be available in older versions of the sandbox.\n\n    Args:\n        file: the file to be sent for analysis\n        file_name:\n            The name of the file to be checked, which will be displayed in the sandbox web interface.\n\n            If possible, the name of the uploaded file will be taken as the default value.\n\n            If not specified, the hash value of the file is calculated using the SHA\u2014256 algorithm.\n        rules: if you have compiled the rules, then you can scan with them, rather than using the sandbox embedded inside\n        priority: the priority of the task, between 1 and 4. The higher it is, the faster it will get to work\n        short_result:\n            Return only the overall result of the check.\n\n            The parameter value is ignored (true is used) if the value of the `async_result` parameter is also `true`.\n        async_result:\n            Return only the scan_id.\n\n            Enabling this option may be usefull to send async requests for file checking.\n\n            You can receive full report in a separate request.\n        read_timeout: response waiting time in seconds\n        upload_timeout: if a large enough file is being uploaded, increase timeout (in seconds).\n        sandbox: additional sandbox options\n\n    Returns:\n        The response from the sandbox is either with partial information (when using async_result), or with full information.\n\n    Raises:\n        SandboxUploadException: if an error occurred when uploading files to the server\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    upload_name: str | None = file_name\n    if not upload_name:\n        match file:\n            case str() | PathLike():\n                upload_name = str(file)\n            case _:\n                upload_name = None\n\n    try:\n        async with asyncio.TaskGroup() as tg:\n            task_file = tg.create_task(self.api.upload_file(file=file, upload_timeout=upload_timeout))\n            if rules is not None:\n                task_rules = tg.create_task(self.api.upload_file(file=rules, upload_timeout=upload_timeout))\n            else:\n                task_rules = None\n\n            if extra_files is not None:\n                tasks_extra_files = {str(file): tg.create_task(self.api.upload_file(file)) for file in extra_files}\n            else:\n                tasks_extra_files = None\n    except* aiohttp.client_exceptions.ClientResponseError as e:\n        raise SandboxUploadException(\"Can't upload files to server\") from e\n\n    uploaded_file = task_file.result()\n\n    if tasks_extra_files is not None:\n        for name, task in tasks_extra_files.items():\n            uri = task.result().data.file_uri\n            sandbox.extra_files.append(SandboxOptionsAdvanced.ExtraFile(name=name, uri=uri))\n\n    if task_rules is not None:\n        uploaded_rules = task_rules.result()\n        sandbox.debug_options[\"rules_url\"] = uploaded_rules.data.file_uri\n\n    scan = SandboxAdvancedScanTaskRequest(\n        file_uri=uploaded_file.data.file_uri,\n        file_name=upload_name,\n        short_result=short_result,\n        async_result=async_result,\n        priority=priority,\n        sandbox=sandbox,\n    )\n\n    return await self.api.create_advanced_scan(scan, read_timeout)\n</code></pre>"},{"location":"usage/public-api/scanning/scan/#options_1","title":"Options","text":"<p>A set of options that additionally allow you to configure the analysis parameters</p> <p>In them, you can set the scan image, your command to run, etc.</p> <p>You can read more details in the model code.</p> Source code in <code>ptsandbox/models/api/analysis.py</code> <pre><code>class SandboxOptionsAdvanced(BaseRequest):\n    \"\"\"\n    Run an advanced analysis of the uploaded file in the VM without unpacking.\n\n    Provides an opportunity to fine-tuning.\n\n    **The options are in beta, so they may change in the future.**\n    \"\"\"\n\n    class ExtraFile(BaseModel):\n        \"\"\"\n        An additional file to be placed next to the sample\n        \"\"\"\n\n        uri: str\n        \"\"\"\n        Link to the uploaded object\n        \"\"\"\n\n        name: str\n        \"\"\"\n        Name in the VM\n        \"\"\"\n\n    image_id: str = \"win7-sp1-x64\"\n    \"\"\"\n    ID of the VM image.\n\n    You can view it in the sandbox interface.\n    \"\"\"\n\n    custom_command: str | None = None\n    \"\"\"\n    The command to run the file.\n\n    The `{file}` marker in the string is replaced with the path to the file.\n\n    For example: `rundll32.exe {file},#1`\n    \"\"\"\n\n    procdump_new_processes_on_finish: bool = False\n    \"\"\"\n    Take dumps for all spawned and non-dead processes\n    \"\"\"\n\n    analysis_duration: int = Field(default=120, ge=10)\n    \"\"\"\n    The duration of analysis the file in seconds. minimum: 10\n    \"\"\"\n\n    bootkitmon: bool = False\n    \"\"\"\n    Perform bootkitmon analysis\n    \"\"\"\n\n    analysis_duration_bootkitmon: int = Field(default=60, ge=10)\n    \"\"\"\n    The duration of analysis at the bootkitmon stage in seconds. minimum: 10\n    \"\"\"\n\n    save_video: bool = True\n    \"\"\"\n    Save video capture of the screen\n    \"\"\"\n\n    mitm_enabled: bool = True\n    \"\"\"\n    Enable certificates injection with PT Sandbox certificates when decrypting and analyzing secure traffic\n    \"\"\"\n\n    disable_clicker: bool = False\n    \"\"\"\n    Disable auto-clicker startup\n\n    Useful when enabling manual analysis.\n    \"\"\"\n\n    skip_sample_run: bool = False\n    \"\"\"\n    Disable sample launch\n    \"\"\"\n\n    vnc_mode: VNCMode = VNCMode.DISABLED\n    \"\"\"\n    Manual analysis mode\n    \"\"\"\n\n    extra_files: list[ExtraFile] = []\n    \"\"\"\n    A list of additional files that are placed in the VM\n    \"\"\"\n\n    debug_options: DebugOptions = {\"save_debug_files\": False}\n    \"\"\"\n    Fine-tuning\n    \"\"\"\n</code></pre>"},{"location":"usage/public-api/scanning/source/","title":"Sources","text":""},{"location":"usage/public-api/scanning/source/#overview","title":"Overview","text":"<p>The sandbox allows you to create scan sources for which you can pre-configure the scan settings.</p> <p></p> <p>To do this, create a source as shown in the example below and select the appropriate API key for it. In our case - <code>example-source-token</code>.</p> <p></p> <p>Note</p> <p>The API key must have at least the <code>Check with source settings</code> permission.</p> <p>Additional details can be found in the sandbox documentation.</p>"},{"location":"usage/public-api/scanning/source/#scan-files","title":"Scan files","text":"Code example (sync scanning)<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FOR_SOURCE&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    report = await sandbox.source_check_file(\"./malware.exe\") # (1)!\n    print(report)\n\nasyncio.run(main())\n</code></pre> <ol> <li>By default, a short report is returned. For a full report, add the option <code>short_report=False</code></li> </ol> Code example (async scanning)<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FOR_SOURCE&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    task = await sandbox.source_check_file(\n        \"./malware.elf\",\n        async_result=True,\n    )\n\n    report = await sandbox.wait_for_report(\n        response,\n        wait_time=100,\n        scan_with_sources=True, # (1)!\n    )\n\n\nasyncio.run(main())\n</code></pre> <ol> <li>When using asynchronous requests with a source, you must pass the option <code>scan_with_sources=True</code>, otherwise you will get a 401 error.</li> </ol> <p>More parameters can be found below \ud83d\udc47</p> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def source_check_file(\n    self,\n    file: str | Path | bytes | BinaryIO,\n    /,\n    *,\n    file_name: str | None = None,\n    short_result: bool = True,\n    async_result: bool = False,\n    priority: int = 3,\n    passwords_for_unpack: list[str] | None = None,\n    product: str | None = None,\n    metadata: dict[str, str] | None = None,\n    read_timeout: int = 240,\n) -&gt; SandboxBaseTaskResponse:\n    \"\"\"\n    Your application can run a file check with predefined parameters\n    and in response receive the results of the check and/or the ID of the task.\n\n    Args:\n        file:\n            The file to be sent for analysis\n        file_name:\n            The name of the file to be checked, which will be displayed in the sandbox web interface.\n\n            If possible, the name of the uploaded file will be taken as the default value.\n\n            If not specified, the hash value of the file is calculated using the SHA\u2014256 algorithm.\n        short_result:\n            Return only the overall result of the check.\n\n            Attention. When using a query with the full result (short_result=false), the response waiting time can be increased by 2 seconds.\n\n            For example, scanning a file without BA takes an average of hundreds of milliseconds,\n            and you will have to wait seconds to get the full result, which is much longer.\n        async_result:\n            Return only the scan_id without waiting for the scan to finish.\n\n            The \"result\" key is missing in the response.\n        priority:\n            The priority of the task is from 1 to 4. The higher it is, the faster it will get to work.\n        passwords_for_unpack:\n            A list of passwords for unpacking encrypted archives\n        product:\n            The source ID string is \"EDR\" or \"CS\" (\"PT_EDR\" or \"PT_CS\").\n\n            You only need to fill it out during integration\n        metadata:\n            Source metadata for special scanning\n\n            ```python\n            {\n                \"additionalProp1\": \"string\",\n                \"additionalProp2\": \"string\",\n                \"additionalProp3\": \"string\"\n            }\n            ```\n        read_timeout:\n            Response waiting time in seconds\n\n    Raises:\n        ValueError: if passed values incorrect\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    if priority &lt; 1 or priority &gt; 4:\n        raise ValueError(f\"Incorrect value for priority: {priority}\")\n\n    upload_name = file_name\n    if not upload_name:\n        match file:\n            case str() | Path():\n                upload_name = str(file)\n            case _:\n                upload_name = None\n\n    data = SandboxScanWithSourceFileRequest(\n        file_name=upload_name,\n        short_result=short_result,\n        async_result=async_result,\n        priority=priority,\n        passwords_for_unpack=passwords_for_unpack,\n        product=product,\n        metadata=metadata,\n    )\n\n    return await self.api.source_check_file(file, data, read_timeout)\n</code></pre>"},{"location":"usage/public-api/scanning/source/#scan-urls","title":"Scan URLs","text":"Code example (sync scanning)<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FOR_SOURCE&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    report = await sandbox.source_check_url(\"http://malware.com/file.elf\") # (1)!\n    print(report)\n\nasyncio.run(main())\n</code></pre> <ol> <li>By default, a short report is returned. For a full report, add the option <code>short_report=False</code></li> </ol> Code example (async scanning)<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ptsandbox import Sandbox, SandboxKey\n\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FOR_SOURCE&gt;\",\n        host=\"10.10.10.10\",\n    )\n\n    sandbox = Sandbox(key)\n\n    task = await sandbox.source_check_url(\n        \"http://malware.com/file.elf\",\n        async_result=True,\n    )\n\n    report = await sandbox.wait_for_report(\n        response,\n        wait_time=100,\n        scan_with_sources=True, # (1)!\n    )\n\n\nasyncio.run(main())\n</code></pre> <ol> <li>When using asynchronous requests with a source, you must pass the option <code>scan_with_sources=True</code>, otherwise you will get a 401 error.</li> </ol> <p>More parameters can be found below \ud83d\udc47</p> Source code in <code>ptsandbox/sandbox/sandbox.py</code> <pre><code>async def source_check_url(\n    self,\n    url: str,\n    /,\n    *,\n    short_result: bool = True,\n    async_result: bool = False,\n    priority: int = 3,\n    passwords_for_unpack: list[str] | None = None,\n    product: str | None = None,\n    metadata: dict[str, str] | None = None,\n    read_timeout: int = 240,\n) -&gt; SandboxBaseTaskResponse:\n    \"\"\"\n    Your application can run a URL scan and receive the scan results and/or the ID of the task.\n\n    Args:\n        url:\n            The file to be sent for analysis\n        short_result:\n            Return only the overall result of the check.\n\n            Attention. When using a query with the full result (short_result=false), the response waiting time can be increased by 2 seconds.\n\n            For example, scanning a file without BA takes an average of hundreds of milliseconds,\n            and you will have to wait seconds to get the full result, which is much longer.\n        async_result:\n            Return only the scan_id without waiting for the scan to finish.\n\n            The \"result\" key is missing in the response.\n        priority:\n            The priority of the task is from 1 to 4. The higher it is, the faster it will get to work.\n        passwords_for_unpack:\n            A list of passwords for unpacking encrypted archives\n        product:\n            The source ID string is \"EDR\" or \"CS\" (\"PT_EDR\" or \"PT_CS\").\n\n            You only need to fill it out during integration\n        metadata:\n            Source metadata for special scanning\n\n            ```python\n            {\n                \"additionalProp1\": \"string\",\n                \"additionalProp2\": \"string\",\n                \"additionalProp3\": \"string\"\n            }\n            ```\n        read_timeout:\n            Response waiting time in seconds\n\n    Raises:\n        ValueError: if passed values incorrect\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    if priority &lt; 1 or priority &gt; 4:\n        raise ValueError(f\"Incorrect value for priority: {priority}\")\n\n    data = SandboxScanWithSourceURLRequest(\n        url=url,\n        short_result=short_result,\n        async_result=async_result,\n        priority=priority,\n        passwords_for_unpack=passwords_for_unpack,\n        product=product,\n        metadata=metadata,\n    )\n\n    return await self.api.source_check_url(data, read_timeout)\n</code></pre>"},{"location":"usage/ui-api/antiviruses/","title":"Antiviruses","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    engines = await sandbox.ui.get_av_engines()\n    print(engines)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_av_engines(self) -&gt; SandboxAVEnginesResponse:\n    \"\"\"\n    Get information about antivirus scanners\n\n    Returns:\n        A model with information about all antiviruses\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/av-engines\")\n\n    response.raise_for_status()\n\n    return SandboxAVEnginesResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/api-tokens/","title":"API Tokens","text":"<p>You can manage api tokens that are in the sandbox.</p>"},{"location":"usage/ui-api/api-tokens/#get-listing-of-current-public-api-tokens","title":"Get listing of current Public API tokens","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    tokens = await sandbox.ui.get_api_tokens()\n    print(tokens)\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/tokens.py</code> <pre><code>class SandboxTokensResponse(BaseModel):\n    \"\"\"\n    Listing of current Public API tokens\n    \"\"\"\n\n    total: int\n    \"\"\"\n    The number of tokens in the system\n    \"\"\"\n\n    entries: list[Token] = []\n    \"\"\"\n    List of tokens\n    \"\"\"\n</code></pre>"},{"location":"usage/ui-api/api-tokens/#create-a-new-public-api-token","title":"Create a new Public API token","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import TokenPermissions\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    token = await sandbox.ui.create_api_token(\n        name=\"test-token\",\n        permissions=[\n            TokenPermissions.SCAN_WITH_EXTENDED_SETTINGS,\n            TokenPermissions.SCAN_WITH_PREDEFINED_SETTINGS,\n        ],\n        comment=\"test-comment\",\n    )\n    print(token)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>async def create_api_token(\n    self,\n    name: str,\n    permissions: list[TokenPermissions],\n    comment: str = \"\",\n) -&gt; SandboxCreateTokenResponse:\n    \"\"\"\n    Create a new Public API token\n\n    Args:\n        name: token name\n        permissions: permissions for the token\n        comment: additional information about the token\n\n    Returns:\n        A model with information about the created token\n    \"\"\"\n\n    response = await self.http_client.post(\n        f\"{self.key.ui_url}/public-api/tokens\",\n        json={\n            \"name\": name,\n            \"permissions\": permissions,\n            \"comment\": comment,\n        },\n    )\n\n    response.raise_for_status()\n\n    return SandboxCreateTokenResponse.model_validate(await response.json())\n</code></pre> Response model in <code>ptsandbox/models/ui/tokens.py</code> <pre><code>class SandboxCreateTokenResponse(Token):\n    token: str\n    \"\"\"\n    The secret value of the token, which is shown only when creating a new PublicAPI token.\n    \"\"\"\n\n    key: str\n    \"\"\"\n    Hash of the secret value\n    \"\"\"\n</code></pre>"},{"location":"usage/ui-api/api-tokens/#delete-the-public-api-token","title":"Delete the Public API token","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import TokenPermissions\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    await sandbox.ui.delete_api_token(token_id=1337)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>async def delete_api_token(self, token_id: int) -&gt; None:\n    \"\"\"\n    Delete the Public API token\n\n    Args:\n        token_id: id of the PublicAPI token in the database\n    \"\"\"\n\n    response = await self.http_client.delete(f\"{self.key.ui_url}/public-api/tokens/{token_id}\")\n\n    response.raise_for_status()\n</code></pre>"},{"location":"usage/ui-api/artifacts/","title":"Artifacts","text":""},{"location":"usage/ui-api/artifacts/#export-in-csv","title":"Export in csv","text":"Code example<pre><code>import asyncio\nimport aiofiles\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    async with aiofiles.open(\"./tasks.csv\", \"wb\") as fd:\n        async for chunk in sandbox.ui.get_artifacts_csv():\n            await fd.write(chunk)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_artifacts_csv(\n    self,\n    query: str = \"\",\n    columns: (\n        list[\n            Literal[\n                \"behavioralAnalysis\",\n                \"bwListStatus\",\n                \"createProcess\",\n                \"detects.avast\",\n                \"detects.clamav\",\n                \"detects.drweb\",\n                \"detects.eset\",\n                \"detects.kaspersky\",\n                \"detects.nano\",\n                \"detects.ptesc\",\n                \"detects.vba\",\n                \"detects.yara\",\n                \"detects.yara.test\",\n                \"emlBcc\",\n                \"emlCC\",\n                \"emlFrom\",\n                \"emlTo\",\n                \"fileExtensionTypeGroup\",\n                \"fileLabels\",\n                \"fileMd5\",\n                \"fileName\",\n                \"fileSha1\",\n                \"fileSha256\",\n                \"fileSize\",\n                \"fileType\",\n                \"fromTo\",\n                \"imageDuration\",\n                \"imageName\",\n                \"mimeType\",\n                \"nodeType\",\n                \"priority\",\n                \"receivedFrom\",\n                \"ruleEngineDetects\",\n                \"ruleEngineVerdict\",\n                \"sandboxBehavioral\",\n                \"sandboxBootkitmon\",\n                \"sandboxDetects\",\n                \"sandboxVerdict\",\n                \"smtpFrom\",\n                \"smtpTo\",\n                \"source\",\n                \"ssdeep\",\n                \"status\",\n                \"subject\",\n                \"taskId\",\n                \"time\",\n                \"verdict\",\n                \"verdict.avast\",\n                \"verdict.clamav\",\n                \"verdict.drweb\",\n                \"verdict.eset\",\n                \"verdict.kaspersky\",\n                \"verdict.nano\",\n                \"verdict.ptesc\",\n                \"verdict.vba\",\n                \"verdict.yara\",\n                \"verdict.yara.test\",\n                \"verdictPriority\",\n                \"verdictReason\",\n            ]\n        ]\n        | None\n    ) = None,\n    utc_offset_seconds: int = 0,\n) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Export an artifacts listing to CSV\n\n    Args:\n        query: filtering using the query language. For the syntax, see the user documentation.\n        columns: the list of csv columns to be exported.\n        utc_offset_seconds: the offset of the user's time from UTC, which will be used for the time in QL queries\n\n    Returns:\n        AsyncIterator with chunks of CSV file\n    \"\"\"\n\n    if columns is None:\n        columns = []\n\n    data: dict[str, Any] = {\n        \"format\": \"CSV\",  # only csv supported by now\n        \"query\": query,\n        \"columns\": \",\".join(columns),\n        \"utcOffsetSeconds\": utc_offset_seconds,\n    }\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/artifacts/export\", params=data)\n\n    response.raise_for_status()\n\n    async for chunk in response.content.iter_chunked(1024 * 1024):\n        yield chunk\n</code></pre>"},{"location":"usage/ui-api/artifacts/#get-filter-values","title":"Get filter values","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    values = await sandbox.ui.get_artifacts_filter_values()\n    print(values)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_artifacts_filter_values(\n    self,\n    from_: str = \"\",\n    to: str = \"\",\n    scan_id: UUID | None = None,\n) -&gt; SandboxArtifactsFilterValuesResponse:\n    \"\"\"\n    Get possible values for filters based on sources and validation results\n\n    Args:\n        from_: for which period possible values are being searched: minimum time\n        to: for which period possible values are being searched: maximum time\n        scan_id: filter by task ID\n\n    Returns:\n        Possible filter values\n    \"\"\"\n\n    data: dict[str, Any] = {}\n    if scan_id is not None:\n        data.update({\"scanId\": scan_id})\n\n    if from_:\n        data.update({\"from\": from_})\n\n    if to:\n        data.update({\"to\": to})\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/artifacts/filter-values\", params=data)\n\n    response.raise_for_status()\n\n    return SandboxArtifactsFilterValuesResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/authorization/","title":"Authorization","text":"<p>Due to the specific API, not all useful functions are available directly through the <code>Public API</code>. Therefore, a connector to the UI API was written for this purpose.</p> Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-key-1\",\n        key=\"&lt;TOKEN_FROM_SANDBOX&gt;\",\n        host=\"10.10.10.10\",\n        ui=SandboxKey.UI(\n            login=\"login\",\n            password=\"password\",\n        ),\n    )\n\n    sandbox = Sandbox(key)\n    await sandbox.ui.authorize() # (1)!\n\nasyncio.run(main())\n</code></pre> <ol> <li>You must log in before using the API.</li> </ol> <p>Sometimes it becomes necessary to use the UI API without access to the Public API. To do this, you can initialize the key in this way:</p> Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    key = SandboxKey(\n        name=\"test-ui-1\",\n        key=\"\", # (1)!\n        host=\"10.10.10.10\",\n        ui=SandboxKey.UI(\n            login=\"login\",\n            password=\"password\",\n        ),\n    )\n\n    sandbox = Sandbox(key)\n    await sandbox.ui.authorize()\n</code></pre> <ol> <li>Just pass an empty <code>key</code> field</li> </ol>"},{"location":"usage/ui-api/baqueue/","title":"BAqueue","text":"<p>You can get information about the Behavioral Analysis queue.</p> <p>By default, all jobs that are currently running are requested.</p> Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    baqueue = await sandbox.ui.get_baqueue_tasks()\n    for task in baqueue.tasks:\n        print(task.object_name, task.state)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_baqueue_tasks(\n    self,\n    query: str = \"age &lt; 7d AND state IN (CREATED, STARTING, STARTED, DEDUPLICATION, READY, READY_WITH_ERROR) ORDER BY state DESC, priority.value DESC, ts.created\",\n    limit: int = 50,\n    offset: int = 0,\n    utc_offset_seconds: int = 0,\n) -&gt; SandboxBaqueueTasksResponse:\n    \"\"\"\n    Listing of tasks in the Behavioral Analysis queue\n\n    Args:\n        query: QL search query (by default, all tasks that are currently running are requested)\n        limit: limit on the number of records to be returned\n        offset: offset of returned records\n        utc_offset_seconds: the offset of the user's time from UTC, which will be used for the time in QL queries\n    \"\"\"\n\n    data: dict[str, Any] = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"query\": query,\n        \"utcOffsetSeconds\": utc_offset_seconds,\n    }\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/baqueue/tasks\", params=data)\n\n    response.raise_for_status()\n\n    return SandboxBaqueueTasksResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/cluster/","title":"Cluster","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    cluster = await sandbox.ui.get_system_cluster_status()\n    print(cluster)\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/cluster.py</code> <pre><code>class SandboxClusterStatusResponse(BaseModel):\n    \"\"\"\n    Cluster information\n    \"\"\"\n\n    class Node(BaseModel):\n        class Condition(BaseModel):\n            type: str\n            message: str\n\n        class Info(BaseModel):\n            \"\"\"\n            System Information: Component versions\n            \"\"\"\n\n            kubernetes: str\n            \"\"\"\n            Kubernetes version\n            \"\"\"\n\n            container_runtime: str = Field(alias=\"containerRuntime\")\n            \"\"\"\n            Containerd version\n            \"\"\"\n\n            os: str\n\n            os_image: str = Field(alias=\"osImage\")\n\n            os_kernel: str = Field(alias=\"osKernel\")\n\n            xen_version: str = Field(alias=\"xenVersion\")\n\n            vm_cpu: int = Field(alias=\"vmCpu\")\n            \"\"\"\n            The number of cores allocated for the BA\n            \"\"\"\n\n            vm_ram: int = Field(alias=\"vmRam\")\n            \"\"\"\n            The amount of RAM allocated for the BA in Bytes\n            \"\"\"\n\n        class IPs(BaseModel):\n            class IP(BaseModel):\n                type: str\n                ip: str\n\n            internal: IP\n            cluster: IP\n\n        name: str\n\n        hostname: str = Field(alias=\"hostName\")\n\n        ready: bool\n        \"\"\"\n        Node status\n        \"\"\"\n\n        cpu: int\n        \"\"\"\n        Number of cores\n        \"\"\"\n\n        ram: int\n        \"\"\"\n        The amount of RAM in Bytes\n        \"\"\"\n\n        vm_capacity: int = Field(alias=\"vmCapacity\")\n        \"\"\"\n        The number of traps per node. Total capacity.\n        \"\"\"\n\n        vm_allocatable: int = Field(alias=\"vmAllocatable\")\n        \"\"\"\n        The number of traps per node. Currently in use.\n        \"\"\"\n\n        conditions: list[Condition]\n        \"\"\"\n        Problematic conditions on the node Problematic conditions on the node will be shown here.\n\n        Examples of conditions:\n\n        ```\n        [\n            { \"message\": \"Calico is not running on this node\", \"type\": \"NetworkUnavailable\" },\n            { \"message\": \"kubelet has unsufficient memory available\", \"type\": \"MemoryPressure\" },\n            { \"message\": \"kubelet has disk pressure\", \"type\": \"DiskPressure\" },\n            { \"message\": \"Kubelet stopped posting node status.\", \"type\": \"Ready\" }\n        ]\n        ```\n        \"\"\"\n\n        total_pods: int = Field(alias=\"totalPods\")\n        \"\"\"\n        The total number of pods per node\n        \"\"\"\n\n        ready_pods: int = Field(alias=\"readyPods\")\n\n        running_pods: int | None = Field(default=None, alias=\"runningPods\")\n        \"\"\"\n        The number of working pods on the node\n        \"\"\"\n\n        roles: list[str]\n        \"\"\"\n        Node labels\n        \"\"\"\n\n        info: Info\n\n        ips: IPs\n\n    high_availability: bool = Field(alias=\"highAvailability\")\n    \"\"\"\n    High availability mode\n    \"\"\"\n\n    cluster_ip: str = Field(alias=\"clusterIp\")\n\n    sb_nodes: int = Field(alias=\"sbNodes\")\n    \"\"\"\n    Number of nodes\n    \"\"\"\n\n    sb_nodes_available: int = Field(alias=\"sbNodesAvailable\")\n    \"\"\"\n    Number of available BA nodes\n    \"\"\"\n\n    vms_count: int = Field(alias=\"vmsCount\")\n    \"\"\"\n    Number of VMs\n    \"\"\"\n\n    vms_count_available: int = Field(alias=\"vmsCountAvailable\")\n    \"\"\"\n    Number of available VMs\n    \"\"\"\n\n    nodes: list[Node] = []\n    \"\"\"\n    List of nodes\n    \"\"\"\n</code></pre>"},{"location":"usage/ui-api/components/","title":"Components","text":"<p>Get information about system components</p> Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    data = await sandbox.ui.get_system_components_status()\n    for component in data.components:\n        print(component.name, component.status, \",\".join(x.name for x in component.pods))\n\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/components.py</code> <pre><code>class SandboxComponentsResponse(BaseModel):\n    \"\"\"\n    Information about system components\n    \"\"\"\n\n    class Component(BaseModel):\n        class Pod(BaseModel):\n            name: str\n\n            component_name: str = Field(alias=\"componentName\")\n            \"\"\"\n            Which component does it belong to\n            \"\"\"\n\n            ready: bool\n            \"\"\"\n            Ready status\n            \"\"\"\n\n            node: str\n            \"\"\"\n            The name of the node it is running on\n            \"\"\"\n\n            restarts: int\n\n            error_reason: str = Field(alias=\"errorReason\")\n            \"\"\"\n            The type of error, if any\n            \"\"\"\n\n            error_message: str = Field(alias=\"errorMessage\")\n            \"\"\"\n            Error message, if any\n            \"\"\"\n\n            uptime: int\n            \"\"\"\n            Time elapsed since the container was launched (in seconds)\n            \"\"\"\n\n            containers_running: int = Field(alias=\"containersRunning\")\n            \"\"\"\n            The number of working containers for a given hearth\n            \"\"\"\n\n            containers_total: int = Field(alias=\"containersTotal\")\n            \"\"\"\n            The total number of containers specified in the pod specification (excluding init containers)\n            \"\"\"\n\n        name: str\n\n        total_pods: int = Field(alias=\"totalPods\")\n        \"\"\"\n        How many pods are there in total\n        \"\"\"\n\n        ready_pods: int = Field(alias=\"readyPods\")\n        \"\"\"\n        How many are running\n        \"\"\"\n\n        nodes: list[str]\n        \"\"\"\n        The list of nodes running the component's pods\n        \"\"\"\n\n        status: ComponentStatus\n        \"\"\"\n        Component status\n        \"\"\"\n\n        type: ComponentType\n        \"\"\"\n        Component type\n        \"\"\"\n\n        pods: list[Pod] = []\n        \"\"\"\n        \u0421\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u0434\u043e\u0432\n        \"\"\"\n\n    components: list[Component] = []\n</code></pre>"},{"location":"usage/ui-api/download-files/","title":"Download files","text":"<p>As noted in Download files (Public API), the sandbox has restrictions on downloading files from the task.</p> <p>In order to circumvent this limitation, you can download files using the UI API.</p> Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey, StorageItem\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    data = await sandbox.ui.get_system_components_status()\n    items: list[StorageItem] = [\n        {\"sha256\": \"...\"},\n        {\"sha256\": \"...\", \"name\": \"...\"}\n    ]\n\n    async with aiofiles.open(\"./artifacts.zip\", \"wb\") as fd:\n        async for chunk in sandbox.ui.get_files(items):\n            await fd.write(chunk)\n</code></pre> <p>Note</p> <p>A zip archive with the password \"infected\" is returned, so you need to process the archive yourself.</p> <p>For example, using <code>pyzipper</code>.</p> <p>Download logs from recent tasks</p> <pre><code>import asyncio\nfrom pathlib import Path\n\nimport aiofiles\n\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import StorageItem, ScanArtifactType\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    tasks = await sandbox.ui.get_tasks()\n    for task in tasks.tasks:\n        summary = await sandbox.ui.get_task_tree(task.id)\n\n        items: list[StorageItem] = []\n\n        for children in summary.children:\n            if not children.scan_artifacts:\n                continue\n\n            for artifact in children.scan_artifacts:\n                if artifact.type in {\n                    ScanArtifactType.CORRELATED,\n                    ScanArtifactType.NORMALIZED,\n                    ScanArtifactType.DEBUG,\n                    ScanArtifactType.VIDEO,\n                }:\n                    items.append({\"sha256\": artifact.sha256, \"name\": artifact.name})\n\n        path = Path(\"./tasks\") / str(task.id)\n        path.mkdir(parents=True, exist_ok=True)\n\n        async with aiofiles.open(path / \"logs.zip\", \"wb\") as fd:\n            async for chunk in sandbox.ui.get_files(items):\n                await fd.write(chunk)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/ui-api/entry-points/","title":"Entry Points","text":"<p>You can manage sources using the API.</p> <p>Note</p> <p>This is not a super stable API yet and may be improved in the future.</p>"},{"location":"usage/ui-api/entry-points/#get-a-list-of-possible-sources-to-check-with-their-parameters","title":"Get a list of possible sources to check with their parameters","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    entry_points_types = await sandbox.ui.get_entry_points_types()\n    print(entry_points_types)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_entry_points_types(self) -&gt; SandboxEntryPointsTypesResponse:\n    \"\"\"\n    Get a list of possible sources to check with their parameters\n\n    Returns:\n        List of possible sources\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/entry-points-types\")\n\n    response.raise_for_status()\n\n    return SandboxEntryPointsTypesResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/entry-points/#get-a-list-of-added-sources-for-verification","title":"Get a list of added sources for verification","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    entry_points = await sandbox.ui.get_entry_points()\n    print(entry_points)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_entry_points(self) -&gt; SandboxEntryPointsResponse:\n    \"\"\"\n    Get a list of added sources for analysis\n\n    Returns:\n        EntryPoints model\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/entry-points\")\n\n    response.raise_for_status()\n\n    return SandboxEntryPointsResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/entry-points/#create-a-new-source","title":"Create a new source","text":"<p>Warning</p> <p>Creating a new source requires special configuration. Not all parameters may be suitable for each source type.</p> <p>It is recommended to study the documentation, or find out the necessary parameters through the dev tools in the browser.</p> Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import (\n    EntryPointSettings,\n    EntryPointToken,\n    EntryPointTypeUI,\n    SandboxCreateEntryPointRequest,\n)\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    await sandbox.ui.create_entry_point(\n        SandboxCreateEntryPointRequest(\n            name=\"test-source\",\n            type=EntryPointTypeUI.scan_api,\n            settings=EntryPointSettings(\n                token=EntryPointToken(\n                    id=1337,\n                    name=\"test-token\",\n                )\n            ),\n        )\n    )\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def create_entry_point(self, parameters: SandboxCreateEntryPointRequest) -&gt; None:\n    \"\"\"\n    Add a new analysis source\n\n    Args:\n        parameters:\n            Parameters for request\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    response = await self.http_client.post(\n        f\"{self.key.ui_url}/entry-points\",\n        json=parameters.dict(),\n    )\n\n    response.raise_for_status()\n</code></pre>"},{"location":"usage/ui-api/entry-points/#get-full-information-about-a-specific-source","title":"Get full information about a specific source","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    info = await sandbox.ui.get_entry_point(\"...\")\n    print(info)\n\nasyncio.run(main())\n</code></pre> <p>Get info about all sources on system</p> <pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    entry_points = await sandbox.ui.get_entry_points()\n    for entry_point in entry_points.data:\n        info = await sandbox.ui.get_entry_point(entry_point.id)\n        print(info.data.name, info.data.enabled)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_entry_point(self, entry_point_id: str) -&gt; SandboxEntryPointResponse:\n    \"\"\"\n    Get information about the analysis source\n\n    Args:\n        entry_point_id:\n            Name of entry point\n\n    Returns:\n        EntryPoint model\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/entry-points/{entry_point_id}\")\n\n    response.raise_for_status()\n\n    return SandboxEntryPointResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/entry-points/#remove-the-source-from-the-system","title":"Remove the source from the system","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    await sandbox.ui.delete_entry_point(\"...\")\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def delete_entry_point(self, entry_point_id: str) -&gt; None:\n    \"\"\"\n    Delete the analysis source\n\n    Args:\n        entry_point_id:\n            ID of entry point\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    response = await self.http_client.delete(f\"{self.key.ui_url}/entry-points/{entry_point_id}\")\n\n    response.raise_for_status()\n</code></pre>"},{"location":"usage/ui-api/entry-points/#get-a-list-of-tasks-from-a-specific-source","title":"Get a list of tasks from a specific source","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    tasks = await sandbox.ui.get_entry_point_tasks(\"....\")\n    print(tasks.tasks)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_entry_point_tasks(\n    self,\n    entry_point_id: str,\n    query: str = \"\",\n    limit: int = 20,\n    offset: int = 0,\n    utc_offset_seconds: int = 0,\n    next_cursor: str | None = None,\n) -&gt; SandboxTasksResponse:\n    \"\"\"\n    Listing tasks from the source\n\n    Args:\n        entry_point_id:\n            ID of entry point\n        query:\n            Filtering using the query language. For the syntax, see the user documentation.\n\n            ```\n            age &lt; 30d AND (task.correlated.state != UNKNOWN ) ORDER BY start desc\n            ```\n        limit:\n            Limit on the number of records to be returned\n        offset:\n            The offset of the returned records. If the next Cursor is specified, the offset from the cursor is\n        utc_offset_seconds:\n            The offset of the user's time from UTC, which will be used for the time in QL queries\n\n    Returns:\n        Information about requested tasks\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    data: dict[str, Any] = {\n        \"query\": query,\n        \"limit\": limit,\n        \"offset\": offset,\n        \"utcOffsetSeconds\": utc_offset_seconds,\n    }\n\n    if next_cursor is not None:\n        data.update({\"nextCursor\": next_cursor})\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/entry-points/{entry_point_id}/tasks\", params=data)\n\n    response.raise_for_status()\n\n    return SandboxTasksResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/entry-points/#download-logs-from-the-source","title":"Download logs from the source","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    async with aiofiles.open(\"./logs.zip\", \"wb\") as fd:\n        async for chunk in sandbox.ui.get_entry_point_logs(\"...\"): # (1)!\n            await fd.write(chunk)\n\nasyncio.run(main())\n</code></pre> <ol> <li>Since the size of the logs can reach several gigabytes, the response is returned as an asynchronous iterator, so as not to store all the information in the application's memory.</li> </ol> Source code <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_entry_point_logs(self, entry_point_id: str) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Download logs of a specific source\n\n    Args:\n        entry_point_id:\n            ID of entry point\n\n    Returns:\n        Archive with logs\n\n    Raises:\n        aiohttp.client_exceptions.ClientResponseError: if the response from the server is not ok\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/entry-points/{entry_point_id}/logs\")\n\n    response.raise_for_status()\n\n    async for chunk in response.content.iter_chunked(1024 * 1024):\n        yield chunk\n</code></pre>"},{"location":"usage/ui-api/license/","title":"License","text":""},{"location":"usage/ui-api/license/#get-information-about-license","title":"Get information about license","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    license = await sandbox.ui.get_license()\n    print(license)\n\nasyncio.run(main())\n</code></pre> <p>Check if the license has expired or not</p> <pre><code>import asyncio\nfrom datetime import datetime, timezone\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    key = SandboxKey(...)\n    sandbox = Sandbox(key)\n\n    await sandbox.ui.authorize()\n\n    response = await sandbox.ui.get_license()\n    if datetime.now(tz=timezone.utc) &gt; response.data.license.expiration_time:\n        print(\"License expired\")\n    else:\n        print(f\"License ok, expires in: {response.data.license.expiration_time}\")\n\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/license.py</code> <pre><code>class SandboxLicenseResponse(BaseModel):\n    \"\"\"\n    License status and details\n    \"\"\"\n\n    class Data(BaseModel):\n        class UpdateStatus(BaseModel):\n            \"\"\"\n            Information about the last attempt to update the license\n            \"\"\"\n\n            error: LicenseUpdateError\n            \"\"\"\n            Error if the status is FAILED\n            \"\"\"\n\n            last_check_status: Literal[\"SUCCESS\", \"FAILED\"] = Field(alias=\"lastCheckStatus\")\n\n            last_check_time: AwareDatetime = Field(alias=\"lastCheckTime\")\n\n            last_success_check_time: AwareDatetime = Field(alias=\"lastSuccessCheckTime\")\n\n            license_update_time: AwareDatetime = Field(alias=\"licenseUpdateTime\")\n            \"\"\"\n            When the license itself was updated, not when it was checked\n            \"\"\"\n\n            product: Literal[\"Sandbox\", \"MultiScanner\"]\n            \"\"\"\n            Product type\n            \"\"\"\n\n        class License(BaseModel):\n            class NodesLimit(BaseModel):\n                multiscanner: int = Field(alias=\"multiScanner\")\n                sandbox_high_performance: int = Field(alias=\"sandboxHighPerformance\")\n                sandbox_low_performance: int = Field(alias=\"sandboxLowPerformance\")\n\n            class Performance(BaseModel):\n                \"\"\"\n                Bandwidth by traffic type\n                \"\"\"\n\n                type: LicensePerformanceType\n                limit: int\n\n            class Sandbox(BaseModel):\n                enabled: bool\n                \"\"\"\n                Is behavioral analysis allowed?\n                \"\"\"\n\n                images: list[str]\n                \"\"\"\n                Images that can be used in behavioral analysis\n                \"\"\"\n\n            class Telemetry(BaseModel):\n                enabled: bool\n                \"\"\"\n                Is telemetry enabled\n                \"\"\"\n\n            entry_points: list[LicenseEntryPoint] = Field(alias=\"entryPoints\")\n            \"\"\"\n            Allowed entrypoints\n            \"\"\"\n\n            expiration_time: AwareDatetime = Field(alias=\"expirationTime\")\n            \"\"\"\n            License expiration date\n            \"\"\"\n\n            external_av_engines: list[LicenseAvEngine] = Field(alias=\"externalAvEngines\")\n            \"\"\"\n            Allowed external engines\n            \"\"\"\n\n            files_per_hour: int = Field(alias=\"filesPerHour\")\n            \"\"\"\n            Throughput capacity\n            \"\"\"\n\n            grace_period: int = Field(alias=\"gracePeriod\")\n            \"\"\"\n            The number of grace period days in seconds\n            \"\"\"\n\n            perpetual: bool\n            \"\"\"\n            Is the license permanent\n            \"\"\"\n\n            internal_av_engines: list[LicenseAvEngine] = Field(alias=\"internalAvEngines\")\n            \"\"\"\n            Allowed internal engines\n            \"\"\"\n\n            is_entry_points_blocking_mode: bool = Field(alias=\"isEntryPointsBlockingMode\")\n            \"\"\"\n            Is blocking mode allowed?\n            \"\"\"\n\n            license_version: int = Field(default=2, alias=\"licenseVersion\")\n            \"\"\"\n            License version\n            \"\"\"\n\n            nodes_limit: NodesLimit = Field(alias=\"nodesLimit\")\n            \"\"\"\n            Maximum number of nodes by type\n            \"\"\"\n\n            number: int\n            \"\"\"\n            License number issued\n            \"\"\"\n\n            performance: list[Performance] = []\n            \"\"\"\n            Bandwidth by traffic type\n            \"\"\"\n\n            sandbox: Sandbox\n\n            telemetry: Telemetry\n\n        state: LicenseStatus\n        \"\"\"\n        License status - is there, is it expired\n        \"\"\"\n\n        serial_number: str = Field(alias=\"serialNumber\")\n        \"\"\"\n        Serial number of the current license\n        \"\"\"\n\n        update_status: UpdateStatus = Field(alias=\"updateStatus\")\n\n        license: License\n\n    data: Data\n</code></pre>"},{"location":"usage/ui-api/license/#update-current-license","title":"Update current license","text":"Code example<pre><code>import asyncio\n\nfrom ptsandbox import Sandbox\nfrom ptsandbox.models import SandboxKey\n\n\nasync def main():\n    sandbox = Sandbox(SandboxKey(...))\n\n    await sandbox.ui.authorize()\n\n    update_result = await sandbox.ui.update_license()\n    print(update_result)\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/license.py</code> <pre><code>class SandboxLicenseUpdateResponse(BaseModel):\n    \"\"\"\n    License update attempt status\n    \"\"\"\n\n    class Data(BaseModel):\n        status: Literal[\"SUCCESS\", \"FAILED\"]\n\n        error: LicenseUpdateError\n\n    data: Data\n</code></pre>"},{"location":"usage/ui-api/system/","title":"System","text":"<p>You can get information about system components</p>"},{"location":"usage/ui-api/system/#status","title":"Status","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    status = await sandbox.ui.get_system_status()\n    print(status)\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/system.py</code> <pre><code>class SandboxSystemStatusResponse(BaseModel):\n    \"\"\"\n    System events are returned here with information about the current state of the system, i.e. a slice of the current state.\n\n    The event may relate to a specific object, in this case the ObjectId field is filled in. Basically, the event codes indicate a specific problem.\n    Some events may contain additional parameters. For example `AV_ENGINE_IN_NOT_GENERAL_AVAILABILITY`\n\n    Description of current errors:\n\n    * `AV_ENGINE_IN_NOT_GENERAL_AVAILABILITY` - the engine is approaching or becoming unavailable. The ObjectId specifies the name of the engine.\n    Example of parameters\n    ```\n    {\n        \"engineCodeName\": \"clamav\",\n        \"distributionPack\": \"...\",\n        \"distributionVersion\": \"1.1.1\",\n        \"maintenanceStatus\": \"END_OF_SUPPORT\"\n    }\n    ```\n\n    * `STORAGE_CAPACITY_EXCEEDED_COMPONENTS_MAX_SIZE_BYTES` - Exceeding limits for a specific component\n\n    * `STORAGE_CAPACITY_EXCEEDED_MINIMUM` - Exceeding the total minimum required free space\n\n    * `COMPONENT_CAPACITY_EXCEEDED_THRESHOLD` - Exceeding the threshold for free space for a specific component (ObjectId)\n\n    * `COMPONENT_CAPACITY_EXCEEDED_MAX_SIZE` - Exceeding the limit for a specific component (ObjectId)\n    A list of possible components, similar to the Settings API: `['incubator', 'quarantine', 'system', 'sandbox_images']`\n\n    * `SANDBOX_RECONFIGURING` - The configuration is being performed.\n\n    * `NODE_IS_NOT_READY` - The node is unavailable (with the not ready status). The ObjectId contains the node name.\n    The parameters indicate the time from which the status changed.\n    ```\n    {\n        \"since\": 1111111.0\n    }\n    ```\n\n    * `COMPONENT_ERROR` - An error in specific components of the group. The ObjectId specifies a group of components. Example:\n    ```\n    {\n        \"code\": \"COMPONENT_ERROR\",\n        \"group\": \"SANDBOX\",\n        \"level\": \"ERROR\",\n        \"objectId\": \"SANDBOX\",\n        \"params\": {\n            \"sb-worker-1\": {\n                \"error_codes\": [\n                    \"OFFLINE\"\n                ]\n            },\n            \"traps-resource-plugin\": {\n                \"error_codes\": [\n                    \"OFFLINE\"\n                ]\n            }\n        }\n        ...\n    }\n    ```\n    This error should be interpreted roughly as: An error of the \"SANDBOX\" subsystem. Affected components: `\"sb-worker-1\", \"traps-resource-plugin\"`\n\n    * `COMPONENT_PARTIALLY_AVAILABLE` - Similar to COMPONENT_ERROR, only it's about the unavailability of a part of the pod, or a decrease in performance\n\n    * `NEW_VERSION_AVAILABLE` - A new version is available. The ObjectId specifies the version\n\n    * `NEW_VERSION_INSTALLATION_SCHEDULED` - A new version is available and it is scheduled for installation. The ObjectId specifies the version. In the settings, the scheduled installation time is\n    ```\n    {\n        \"time\": 1111111\n    }\n    ```\n\n    * `END_OF_SUPPORT_SOON` - Support for the `END_OF_SUPPORT` version will end soon - Support for the version has been discontinued in params\n    ```\n    {\n        \"eosTs\": 1111111\n    }\n    ```\n\n    * `IMAGE_INSTALL_ERROR` - Error when installing the image, the name of the image is entered in the ObjectId.\n\n    * `NODE_HAVE_ERROR` - There are errors on the node. The ObjectId contains the node name. The error types are specified in the parameters.\n    ```\n    {\n        \"error_types\": [\"NetworkUnavailable\", \"MemoryPressure\", \"DiskPressure\"]\n    }\n    ```\n    \"\"\"\n\n    class Event(BaseModel):\n        group: SystemGroup\n        \"\"\"\n        Group (subsystem)\n        \"\"\"\n\n        code: SystemCode\n        \"\"\"\n        Event/Error code\n        \"\"\"\n\n        object_id: str = Field(alias=\"objectId\")\n        \"\"\"\n        The object's ID. It can be an empty string for general events.\n        \"\"\"\n\n        level: Literal[\"INFO\", \"WARNING\", \"ERROR\"]\n        \"\"\"\n        Event/Error level\n        \"\"\"\n\n        created_ts: int = Field(alias=\"createdTs\")\n        \"\"\"\n        Time when the event was created\n        \"\"\"\n\n        updated_ts: int = Field(alias=\"updatedTs\")\n        \"\"\"\n        Event update Time\n        \"\"\"\n\n        params: dict[Any, Any] = dict()\n        \"\"\"\n        Additional event parameters\n        \"\"\"\n\n    events: list[Event]\n</code></pre>"},{"location":"usage/ui-api/system/#settings","title":"Settings","text":""},{"location":"usage/ui-api/system/#get-information","title":"Get information","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    settings = await sandbox.ui.get_system_settings()\n    print(settings)\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/system.py</code> <pre><code>class SandboxSystemSettingsResponse(BaseModel):\n    \"\"\"\n    System Settings\n    \"\"\"\n\n    class Data(BaseModel):\n        class Telemetry(BaseModel):\n            enabled: bool\n            \"\"\"\n            Telemetry status\n            \"\"\"\n\n            send_events: bool = Field(alias=\"sendEvents\")\n\n        class SIEMNotifier(BaseModel):\n            enabled: bool\n            \"\"\"\n            Status of event collection and analysis\n            \"\"\"\n\n            host: str\n            \"\"\"\n            Syslog Server\n            \"\"\"\n\n            port: int\n            \"\"\"\n            Port syslog server\n            \"\"\"\n\n            transport_protocol: Literal[\"tcp\", \"udp\"] = Field(alias=\"transportProtocol\")\n            \"\"\"\n            Transmission protocol\n            \"\"\"\n\n            audit_enabled: bool = Field(alias=\"auditEnabled\")\n            \"\"\"\n            Send audit events to the system log\n            \"\"\"\n\n        class CybsiNotifier(BaseModel):\n            enabled: bool\n            \"\"\"\n            Enabling/disabling sending reports to Cybsi\n            \"\"\"\n\n            api_url: str = Field(alias=\"apiUrl\")\n            \"\"\"\n            Cybsi URL API\n            \"\"\"\n\n            api_key: str = Field(alias=\"apiKey\")\n            \"\"\"\n            Key for the Cybsi API\n            \"\"\"\n\n            share_level: Literal[\"White\", \"Green\", \"Amber\", \"Red\"] = Field(alias=\"shareLevel\")\n            \"\"\"\n            The access level applied to all artifacts\n            \"\"\"\n\n            upload_strategy: UploadStrategy = Field(alias=\"uploadStrategy\")\n            \"\"\"\n            The rule for uploading artifacts\n            \"\"\"\n\n        class EmailNotifier(BaseModel):\n            enabled: bool\n            \"\"\"\n            Enabling/disabling the sending of notifications by mail\n            \"\"\"\n\n            notify_unwanted: bool = Field(alias=\"notifyUnwanted\")\n            \"\"\"\n            Notification of unwanted objects\n            \"\"\"\n\n            locale: str\n            \"\"\"\n            Locale for generated messages\n            \"\"\"\n\n            sender_address: str = Field(alias=\"senderAddress\")\n            \"\"\"\n            Sender's address\n            \"\"\"\n\n            recipients: list[str]\n            \"\"\"\n            List of recipient addresses\n            \"\"\"\n\n            smtp_default_records: list[SMTPDefaultRecord] = Field(alias=\"smtpDefaultRecords\")\n            \"\"\"\n            List of mail servers\n            \"\"\"\n\n        class Authentication(BaseModel):\n            anonymous_deny: bool = Field(alias=\"anonymousDeny\")\n            \"\"\"\n            Anonymous analysis is prohibited\n            \"\"\"\n\n        class Unpacker(BaseModel):\n            passwords: list[str]\n            \"\"\"\n            List of passwords for unpacking password-protected archives\n            \"\"\"\n\n        class EventCombiner(BaseModel):\n            events_eviction_days: int = Field(alias=\"eventsEvictionDays\")\n            \"\"\"\n            Retention period of the verification history\n            \"\"\"\n\n        class Storage(BaseModel):\n            class Settings(BaseModel):\n                bytes: int\n                \"\"\"\n                Size in bytes\n                \"\"\"\n\n                items: int\n                \"\"\"\n                Number of files\n                \"\"\"\n\n            class Components(BaseModel):\n                class Component(BaseModel):\n                    class Settings(BaseModel):\n                        bytes: int\n                        \"\"\"\n                        Size in bytes\n                        \"\"\"\n\n                        items: int\n                        \"\"\"\n                        Number of files\n                        \"\"\"\n\n                    class Threshold(BaseModel):\n                        bytes_percent: int = Field(alias=\"bytesPercent\")\n                        \"\"\"\n                        Percentage of threshold in bytes\n                        \"\"\"\n\n                        items_percent: int = Field(alias=\"itemsPercent\")\n                        \"\"\"\n                        The percentage of the threshold in the number of files\n                        \"\"\"\n\n                    current_limit: Settings = Field(alias=\"currentLimit\")\n\n                    current_size: Settings = Field(alias=\"currentSize\")\n\n                    min_size: Settings = Field(alias=\"minSize\")\n\n                    threshold: Threshold\n\n                sandbox_images: Component = Field(alias=\"sandboxImages\")\n\n                quarantine: Component\n\n                system: Component\n\n                incubator: Component\n\n            capacity: Settings\n\n            current_size: Settings = Field(alias=\"currentSize\")\n\n            components: Components\n\n        class Quarantine(BaseModel):\n            retention_period: int = Field(alias=\"retentionPeriod\")\n            \"\"\"\n            Storage period in quarantine\n            \"\"\"\n\n            use_smtp: bool = Field(alias=\"useSMTP\")\n            \"\"\"\n            Use a backup mail server to forward emails\n            \"\"\"\n\n            smtp_default_records: list[SMTPDefaultRecord] = Field(alias=\"smtpDefaultRecords\")\n            \"\"\"\n            List of mail servers\n            \"\"\"\n\n        class Retro(BaseModel):\n            enabled: bool\n            \"\"\"\n            The status of the retro check\n            \"\"\"\n\n        telemetry: Telemetry\n\n        siem_notifier: SIEMNotifier = Field(alias=\"siemNotifier\")\n\n        cybsi_notifier: CybsiNotifier = Field(alias=\"cybsiNotifier\")\n\n        email_notifier: EmailNotifier = Field(alias=\"emailNotifier\")\n\n        authentication: Authentication\n\n        unpacker: Unpacker\n\n        event_combiner: EventCombiner = Field(alias=\"eventCombiner\")\n\n        storage: Storage\n\n        quarantine: Quarantine\n\n        retro: Retro\n\n    data: Data\n</code></pre>"},{"location":"usage/ui-api/system/#update-information","title":"Update information","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\nfrom ptsandbox.models import SandboxUpdateSystemSettingsRequest\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    await sandbox.ui.update_system_settings(\n        SandboxUpdateSystemSettingsRequest(\n            quarantine=SandboxUpdateSystemSettingsRequest.Quarantine(\n                retention_period=30000,\n            )\n        )\n    )\n\nasyncio.run(main())\n</code></pre> Request model in <code>ptsandbox/models/ui/system.py</code> <pre><code>class SandboxUpdateSystemSettingsRequest(BaseRequest):\n    class SIEMNotifier(BaseModel):\n        enabled: bool | None = None\n        \"\"\"\n        Status of event collection and analysis\n        \"\"\"\n\n        host: str | None = None\n        \"\"\"\n        Syslog Server\n        \"\"\"\n\n        port: int | None = None\n        \"\"\"\n        Port syslog server\n        \"\"\"\n\n        transport_protocol: Literal[\"tcp\", \"udp\"] | None = Field(default=None, serialization_alias=\"transportProtocol\")\n        \"\"\"\n        Transmission protocol\n        \"\"\"\n\n        audit_enabled: bool | None = Field(default=None, serialization_alias=\"auditEnabled\")\n        \"\"\"\n        Send audit events to the system log\n        \"\"\"\n\n    class CybsiNotifier(BaseModel):\n        enabled: bool | None = None\n        \"\"\"\n        Enabling/disabling sending reports to Cybsi\n        \"\"\"\n\n        api_url: str | None = Field(default=None, serialization_alias=\"apiUrl\")\n        \"\"\"\n        Cybsi URL API\n        \"\"\"\n\n        api_key: str | None = Field(default=None, serialization_alias=\"apiKey\")\n        \"\"\"\n        Key for the Cybsi API\n        \"\"\"\n\n        share_level: Literal[\"White\", \"Green\", \"Amber\", \"Red\"] | None = Field(\n            default=None, serialization_alias=\"shareLevel\"\n        )\n        \"\"\"\n        The access level applied to all artifacts\n        \"\"\"\n\n        upload_strategy: UploadStrategy | None = Field(default=None, serialization_alias=\"uploadStrategy\")\n        \"\"\"\n        The rule for uploading artifacts\n        \"\"\"\n\n    class EmailNotifier(BaseModel):\n        enabled: bool\n        \"\"\"\n        Enabling/disabling the sending of notifications by mail\n        \"\"\"\n\n        notify_unwanted: bool = Field(serialization_alias=\"notifyUnwanted\")\n        \"\"\"\n        Notification of unwanted objects\n        \"\"\"\n\n        locale: str\n        \"\"\"\n        Locale for generated messages\n        \"\"\"\n\n        sender_address: str = Field(serialization_alias=\"senderAddress\")\n        \"\"\"\n        Sender's address\n        \"\"\"\n\n        recipients: list[str]\n        \"\"\"\n        List of recipient addresses\n        \"\"\"\n\n        smtp_default_records: list[SMTPDefaultRecord] = Field(serialization_alias=\"smtpDefaultRecords\")\n        \"\"\"\n        List of mail servers\n        \"\"\"\n\n    class Authentication(BaseModel):\n        anonymous_deny: bool = Field(serialization_alias=\"anonymousDeny\")\n        \"\"\"\n        Anonymous analysis is prohibited\n        \"\"\"\n\n    class Unpacker(BaseModel):\n        passwords: list[str]\n        \"\"\"\n        List of passwords for unpacking password-protected archives\n        \"\"\"\n\n    class EventCombiner(BaseModel):\n        events_eviction_days: int = Field(serialization_alias=\"eventsEvictionDays\")\n        \"\"\"\n        Retention period of the verification history\n        \"\"\"\n\n    class Storage(BaseModel):\n        class Components(BaseModel):\n            class Component(BaseModel):\n                class Settings(BaseModel):\n                    bytes: int | None = None\n                    \"\"\"\n                    Size in bytes\n                    \"\"\"\n\n                    items: int | None = None\n                    \"\"\"\n                    Number of files\n                    \"\"\"\n\n                current_limit: Settings = Field(serialization_alias=\"currentLimit\")\n\n            quarantine: Component | None = None\n\n            incubator: Component | None = None\n\n        components: Components\n\n    class Quarantine(BaseModel):\n        retention_period: int | None = Field(default=None, serialization_alias=\"retentionPeriod\")\n        \"\"\"\n        Storage period in quarantine\n        \"\"\"\n\n        use_smtp: bool | None = Field(default=None, serialization_alias=\"useSMTP\")\n        \"\"\"\n        Use a backup mail server to forward emails\n        \"\"\"\n\n        smtp_default_records: list[SMTPDefaultRecord] | None = Field(\n            default=None, serialization_alias=\"smtpDefaultRecords\"\n        )\n        \"\"\"\n        List of mail servers\n        \"\"\"\n\n    class Retro(BaseModel):\n        enabled: bool\n        \"\"\"\n        The status of the retro check\n        \"\"\"\n\n    authentication: Authentication | None = None\n\n    event_combiner: EventCombiner | None = Field(default=None, serialization_alias=\"eventCombiner\")\n\n    quarantine: Quarantine | None = None\n\n    retro: Retro | None = None\n\n    unpacker: Unpacker | None = None\n\n    siem_notifier: SIEMNotifier | None = Field(default=None, serialization_alias=\"siemNotifier\")\n\n    cybsi_notifier: CybsiNotifier | None = Field(default=None, serialization_alias=\"cybsiNotifier\")\n\n    storage: Storage | None = None\n\n    email_notifier: EmailNotifier | None = Field(default=None, serialization_alias=\"emailNotifier\")\n</code></pre>"},{"location":"usage/ui-api/system/#version","title":"Version","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    version = await sandbox.ui.get_system_version()\n    print(version)\n\nasyncio.run(main())\n</code></pre> Response model in <code>ptsandbox/models/ui/system.py</code> <pre><code>class SandboxSystemVersionResponse(BaseModel):\n    class Data(BaseModel):\n        version: str\n\n        eos_ts: int = Field(alias=\"eosTs\")\n\n        eos_status: EOSStatus = Field(alias=\"eosStatus\")\n\n    data: Data\n</code></pre>"},{"location":"usage/ui-api/system/#system-logs","title":"System Logs","text":"Code example<pre><code>import aiofiles\nimport asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    async with aiofiles.open(\"logs.zip\", \"wb\") as fd:\n        async for chunk in sandbox.ui.get_system_logs(): # (1)!\n            await fd.write(chunk)\n\nasyncio.run(main())\n</code></pre> <ol> <li> If you do not pass the parameters, then all logs will be downloaded, and this is a very large amount of data.</li> </ol> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_system_logs(\n    self,\n    since: int | None = None,\n    components: list[str] | None = None,\n) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Download the archive with system logs\n\n    Args:\n        since: the time period for uploading logs in seconds\n        components: component names in the format `{namespace}/{component}`, `{namespace}/{component}`, ... If the field is empty, all components will be downloaded\n\n    Returns:\n        Archive with logs\n    \"\"\"\n\n    if components is None:\n        components = []\n\n    data: dict[str, Any] = {\"components\": \",\".join(components)}\n    if since is not None:\n        data.update({\"since\": since})\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/system/logs\")\n\n    response.raise_for_status()\n\n    async for chunk in response.content.iter_chunked(1024 * 1024):\n        yield chunk\n</code></pre>"},{"location":"usage/ui-api/tasks/","title":"Tasks","text":""},{"location":"usage/ui-api/tasks/#get-all-tasks","title":"Get all tasks","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    tasks = await sandbox.ui.get_tasks()\n    print(tasks)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_tasks(\n    self,\n    query: str = \"\",\n    limit: int = 20,\n    offset: int = 0,\n    utc_offset_seconds: int = 0,\n    next_cursor: str | None = None,\n) -&gt; SandboxTasksResponse:\n    \"\"\"\n    Get tasks listing\n\n    Args:\n        query:\n            filtering using the query language. For the syntax, see the user documentation.\n\n            ```\n            age &lt; 30d AND (task.correlated.state != UNKNOWN ) ORDER BY start desc\n            ```\n        limit: limit on the number of records to be returned\n        offset: the offset of the returned records. If the next Cursor is specified, the offset from the cursor is\n        utc_offset_seconds: the offset of the user's time from UTC, which will be used for the time in QL queries\n\n\n    Returns:\n        Information about requested tasks\n    \"\"\"\n\n    data: dict[str, Any] = {\n        \"query\": query,\n        \"limit\": limit,\n        \"offset\": offset,\n        \"utcOffsetSeconds\": utc_offset_seconds,\n    }\n\n    if next_cursor is not None:\n        data.update({\"nextCursor\": next_cursor})\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks\", params=data)\n\n    response.raise_for_status()\n\n    return SandboxTasksResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/tasks/#export-in-csv","title":"Export in csv","text":"Code example<pre><code>import asyncio\nimport aiofiles\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    async with aiofiles.open(\"./tasks.csv\", \"wb\") as fd:\n        async for chunk in sandbox.ui.get_tasks_csv():\n            await fd.write(chunk)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_tasks_csv(\n    self,\n    query: str = \"\",\n    columns: (\n        list[\n            Literal[\n                \"action\",\n                \"behavioralAnalysis\",\n                \"fromTo\",\n                \"priority\",\n                \"processedTime\",\n                \"quarantine\",\n                \"source\",\n                \"status\",\n                \"taskName\",\n                \"time\",\n                \"verdict\",\n                \"verdictTime\",\n            ]\n        ]\n        | None\n    ) = None,\n    utc_offset_seconds: int = 0,\n) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Export a tasks listing to CSV\n\n    Args:\n        query: filtering using the query language. For the syntax, see the user documentation.\n        columns: the list of csv columns to be exported.\n        utc_offset_seconds: the offset of the user's time from UTC, which will be used for the time in QL queries\n\n    Returns:\n        AsyncIterator with chunks of CSV file\n    \"\"\"\n\n    if columns is None:\n        columns = []\n\n    data: dict[str, Any] = {\n        \"format\": \"CSV\",  # only csv supported by now\n        \"query\": query,\n        \"columns\": \",\".join(columns),\n        \"utcOffsetSeconds\": utc_offset_seconds,\n    }\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks/export\", params=data)\n\n    response.raise_for_status()\n\n    async for chunk in response.content.iter_chunked(1024 * 1024):\n        yield chunk\n</code></pre>"},{"location":"usage/ui-api/tasks/#get-filter-values","title":"Get filter values","text":"Code example<pre><code>import asyncio\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    values = await sandbox.ui.get_tasks_filter_values()\n    print(values)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_tasks_filter_values(\n    self,\n    from_: str = \"\",\n    to: str = \"\",\n    scan_id: UUID | None = None,\n) -&gt; SandboxTasksFilterValuesResponse:\n    \"\"\"\n    Get possible values for filters based on sources and validation results\n\n    Args:\n        from_: for which period possible values are being searched: minimum time\n        to: for which period possible values are being searched: maximum time\n        scan_id: filter by task ID\n\n    Returns:\n        Possible filter values\n    \"\"\"\n\n    data: dict[str, Any] = {}\n    if scan_id is not None:\n        data.update({\"scanId\": scan_id})\n\n    if from_:\n        data.update({\"from\": from_})\n\n    if to:\n        data.update({\"to\": to})\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks/filter-values\", params=data)\n\n    response.raise_for_status()\n\n    return SandboxTasksFilterValuesResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/tasks/#task","title":"Task","text":""},{"location":"usage/ui-api/tasks/#summary","title":"Summary","text":"Code example<pre><code>import asyncio\nfrom uuid import UUID\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    summary = await sandbox.ui.get_task_summary(UUID(\"...\"))\n    print(summary)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_task_summary(self, scan_id: UUID) -&gt; SandboxTasksSummaryResponse:\n    \"\"\"\n    Get information about a specific task\n\n    Args:\n        scan_id: task id\n\n    Returns:\n        Full information about a specific task\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks/{scan_id}/summary\")\n\n    response.raise_for_status()\n\n    return SandboxTasksSummaryResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/tasks/#get-a-tree-of-artifacts-for-a-specific-task","title":"Get a tree of artifacts for a specific task","text":"Code example<pre><code>import asyncio\nfrom uuid import UUID\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    summary = await sandbox.ui.get_task_tree(UUID(\"...\"))\n    print(summary)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_task_tree(\n    self,\n    scan_id: UUID,\n    *,\n    parent_path: list[int] | None = None,\n    filtered_by_ids: list[int] | None = None,\n    limit: int = 1000,\n    offset: int = 0,\n    max_tree_level: int = 3,\n    sort_mode: Literal[\"DANGEROUS\", \"ALPHABETICAL\"] = \"DANGEROUS\",\n) -&gt; SandboxTreeResponse:\n    \"\"\"\n    Get a tree of artifacts for a specific task\n\n    Args:\n        scan_id: ...\n        parent_path: the full path to the parent to start loading the tree from. For example: [0, 2, 10]\n        filtered_by_ids: a list of IDs of specific nodes to be returned, for example: [0, 2, 10, 11]\n        limit: limit on the number of records to be returned\n        offset: the indentation from which the records are returned, used for pagination\n        max_tree_level: the maximum depth (relative to the parent) to be returned\n        sort_mode: the sorting method. First, the dangerous ones are 'DANGEROUS' or just alphabetically 'ALPHABETIC'\n\n    Returns:\n        The Artifact Tree\n    \"\"\"\n\n    data: dict[str, Any] = {\"limit\": limit, \"offset\": offset, \"maxTreeLevel\": max_tree_level, \"sortMode\": sort_mode}\n    if parent_path is not None:\n        data.update({\"parentPath\": \",\".join(map(str, parent_path))})\n    if filtered_by_ids is not None:\n        data.update({\"filteredByIds\": \",\".join(map(str, filtered_by_ids))})\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks/{scan_id}/tree\", params=data)\n\n    response.raise_for_status()\n\n    return SandboxTreeResponse.model_validate(await response.json())\n</code></pre>"},{"location":"usage/ui-api/tasks/#download-all-the-artifacts-of-the-task","title":"Download all the artifacts of the task","text":"Code example<pre><code>import asyncio\nimport aiofiles\nfrom uuid import UUID\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    async with aiofiles.open(\"artifacts.zip\", \"wb\") as fd:\n        async for chunk in sandbox.ui.get_task_artifacts(UUID(\"...\")):\n            await fd.write(chunk)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_task_artifacts(\n    self,\n    scan_id: UUID,\n    *,\n    query: str = \"\",\n    include_sandbox_logs: Literal[\"true\", \"false\"] = \"true\",\n    skip_data_files: Literal[\"true\", \"false\"] = \"false\",\n) -&gt; AsyncIterator[bytes]:\n    \"\"\"\n    Download all the artifacts of the task\n\n    Args:\n        scan_id: ...\n        query: filtering using the query language. For the syntax, see the user documentation.\n        include_sandbox_logs: whether to include BA logs as a result\n        skip_data_files: whether to include data files in the result\n\n    Returns:\n        Sandbox returns an encrypted zip archive (password - infected), so we just export a set of bytes.\n        If necessary, you can use pyzipper to unpack\n    \"\"\"\n\n    data: dict[str, Any] = {\n        \"query\": query,\n        \"includeSandboxLogs\": include_sandbox_logs,\n        \"skip_data_files\": skip_data_files,\n    }\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks/{scan_id}/tree/download\", params=data)\n\n    response.raise_for_status()\n\n    async for chunk in response.content.iter_chunked(1024 * 1024):\n        yield chunk\n</code></pre>"},{"location":"usage/ui-api/tasks/#get-scan-result-for-a-specific-artifact","title":"Get scan result for a specific artifact","text":"Code example<pre><code>import asyncio\nfrom uuid import UUID\nfrom ptsandbox import Sandbox, SandboxKey\n\nasync def main():\n    sandbox = Sandbox(...)\n    await sandbox.ui.authorize()\n\n    scan_id = UUID(\"...\")\n    tree = await sandbox.ui.get_task_tree(scan_id)\n    for children in tree.children:\n        scan = await sandbox.ui.get_task_artifact_scans(scan_id, children.node_id)\n\nasyncio.run(main())\n</code></pre> Source code in <code>ptsandbox/sandbox/sandbox_ui.py</code> <pre><code>@_token_required\nasync def get_task_artifact_scans(self, scan_id: UUID, node_id: int) -&gt; SandboxScansResponse:\n    \"\"\"\n    Getting scan results for a specific artifact\n\n    Args:\n        scan_id: ...\n        node_id: ...\n\n    Returns:\n        The model with the scan results\n    \"\"\"\n\n    response = await self.http_client.get(f\"{self.key.ui_url}/v2/tasks/{scan_id}/artifacts/{node_id}/scans\")\n\n    response.raise_for_status()\n\n    return SandboxScansResponse.model_validate(await response.json())\n</code></pre>"}]}